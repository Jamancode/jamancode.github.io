
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dein Angelfreund</title>

    <!-- PWA Manifest and iOS specific tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Angelfreund">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- jsPDF für PDF Export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        /* CSS Variables & Modern Design System */
        :root {
            --primary-gradient: linear-gradient(135deg, #40127c 0%, #1a0129 100%);
            --water-gradient: linear-gradient(180deg, rgba(70, 11, 148, 0.101) 0%, rgba(255, 255, 255, 0.087) 100%);
            --success-gradient: linear-gradient(135deg, #11998e 0%, #179246 100%);
            --danger-gradient: linear-gradient(135deg, #f85032 0%, #e73827 100%);
            --warning-gradient: linear-gradient(135deg, #f98900 0%, #9f871b 100%);
            --neutral-gradient: linear-gradient(135deg, #ada996 0%, #899cc5 50%, #dbdbdb 100%);

            --text-primary: #1a2325;
            --text-secondary: #1a2525;
            --bg-primary: #ffffff;
            --bg-secondary: #c0d4e7; /* Heller Hintergrund für Elemente auf --bg-primary */
            --bg-tertiary: hsl(209, 21%, 51%); /* Etwas dunkler als secondary, gut für List Items auf secondary */
            /* For map instructions text background */
            --bg-primary-rgb: 255,255,255;


            --shadow-sm: 0 2px 4px rgba(0,0,0,0.05); /* Subtilerer Schatten */
            --shadow-md: 0 4px 6px rgba(0,0,0,0.07); /* Subtilerer Schatten */
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.08);
            --shadow-xl: 0 20px 25px rgba(0,0,0,0.1);

            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-xl: 24px;

            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Dark Mode Variables */
        [data-theme="dark"] {
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --bg-primary: #1e30b9e9;
            --bg-secondary: #2035aadb; /* Etwas heller als primary für Kartenhintergrund */
            --bg-tertiary: #2d58c2d5; /* Noch heller für Elemente auf secondary */
            --water-gradient: linear-gradient(180deg, rgba(44, 54, 255, 0.3) 0%, rgba(55, 180, 202, 0.2) 100%);
            --bg-primary-rgb: 25,14,95; /* Corresponds to #190e5f */
        }

        /* Reset & Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body { /* Ermöglicht Scrolling für die gesamte Seite */
            height: 100%;
            overflow-x: hidden; /* Nur horizontales Overflow verhindern */
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background-color var(--transition-normal), color var(--transition-normal);
            /* overflow-x: hidden; -> nach oben verschoben */
        }

        /* Water Animation Background */
        .water-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--water-gradient);
            z-index: -1;
            overflow: hidden;
        }

        .water-bg::before,
        .water-bg::after {
            content: '';
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: waterFlow 20s linear infinite;
        }

        .water-bg::after {
            background-size: 30px 30px;
            animation-duration: 15s;
            animation-direction: reverse;
        }

        @keyframes waterFlow {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Header Styles */
        header {
            background: var(--primary-gradient);
            color: white;
            padding: 1.5rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 1rem;
        }

        h1 {
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            background: linear-gradient(135deg, #ffffff 0%, #e0e0e0 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(98, 96, 96, 0.1);
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 1rem;
            margin: 2rem auto;
            max-width: 1400px;
            padding: 0 1rem;
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .nav-tab {
            background: var(--bg-secondary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            transition: all var(--transition-fast);
            white-space: nowrap;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-primary); /* Textfarbe für inaktive Tabs anpassen */
        }
         [data-theme="dark"] .nav-tab {
            color: var(--text-primary);
        }


        .nav-tab:hover {
            background: var(--bg-tertiary);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: var(--primary-gradient);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Collapsible Section (für Karten UI) */
        .collapsible-section {
            background-color: var(--bg-secondary);
            border: 1px solid var(--bg-tertiary);
            border-radius: var(--radius-md);
            margin-bottom: 1rem;
            overflow: hidden; /* Wichtig für Animation */
        }
        .collapsible-header {
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        .collapsible-header:hover {
            background-color: var(--bg-tertiary);
        }
        .collapsible-content {
            padding: 0 1rem 1rem 1rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .collapsible-content.open {
            max-height: 500px; /* Oder ein anderer passender Wert */
            padding-top: 1rem;
            overflow-y: auto; /* Falls Inhalt größer ist */
        }
        #catchMapSidebar .collapsible-content.open {
            max-height: none; /* Allow full content height, sidebar will scroll */
        }
        .collapsible-header .fa-chevron-down {
            transition: transform 0.3s ease-out;
        }
        .collapsible-header.open .fa-chevron-down {
            transform: rotate(180deg);
        }


        /* Weather Widget */
        .weather-widget {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-xl);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all var(--transition-normal);
        }

        .weather-widget:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }

        .weather-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .weather-item i {
            font-size: 1.2rem;
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        /* Card Styles */
        .card {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
            transition: all var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transform-origin: left;
            transition: transform var(--transition-normal);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-xl);
        }

        .card:hover::before {
            transform: scaleX(1);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Angelgang Status Card */
        .angelgang-status {
            text-align: center;
            padding: 2rem;
        }

        .angelgang-timer {
            font-size: 3rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            background-clip: text; /* Standard-Eigenschaft hinzugefügt */
            -webkit-text-fill-color: transparent;
            margin: 1rem 0;
        }

        .angelgang-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 2rem;
        }

        .angelgang-info-item {
            background: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: var(--radius-md);
        }

        /* Gewässer Map */
        #gewaesserMapContainer {
            margin-bottom: 1rem;
        }
        #gewaesserMap {
            height: 450px; /* Increased height */
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            width: 100%; /* Full width of its container */
        }
        /* Map in Gewaesser Modal */
        #gewaesserLocationMap { /* Diese ist im ALTEN Gewässer-Modal */
            height: 200px; /* Verkleinert, da Universal-Karte bevorzugt wird */
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-sm);
            margin-top: 0.5rem;
        }
        /* Map in Universal Map Modal */
        #catchLeafletMapContainer {
            flex-grow: 1;
            background: #eee;
            min-height: 200px;
        }
        #catchLeafletMap {
             height: 100%;
             width: 100%;
        }



        .location-search-bar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .location-search-bar input {
            flex-grow: 1;
        }

        /* Bite Probability Display */
        .probability-grid {
            display: grid;
            gap: 1rem;
        }

        .fish-probability {
            background: var(--bg-tertiary);
            padding: 1rem;
            border-radius: var(--radius-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all var(--transition-fast);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .fish-probability:hover {
            transform: translateX(4px);
            background: var(--bg-primary);
        }

        .fish-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .fish-icon {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 1.5rem;
            transition: all var(--transition-normal);
        }

        .probability-high .fish-icon {
            background: var(--success-gradient);
            color: white;
            animation: pulse 2s ease-in-out infinite;
        }

        .probability-medium .fish-icon {
            background: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
            color: white;
        }

        .probability-low .fish-icon {
            background: var(--danger-gradient);
            color: white;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .probability-bar {
            width: 120px;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-sm);
            overflow: hidden;
            position: relative;
        }

        .probability-fill {
            height: 100%;
            border-radius: var(--radius-sm);
            transition: width var(--transition-slow);
            background: var(--success-gradient);
            position: relative;
            overflow: hidden;
        }

        .probability-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Calendar Styles */
        .calendar-container {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            margin-top: 2rem;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .calendar-nav {
            display: flex;
            gap: 1rem;
        }

        .btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-weight: 600;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
            display: inline-flex; /* Für Icon und Text Zentrierung */
            align-items: center;
            justify-content: center;
            gap: 0.5rem; /* Abstand zwischen Icon und Text */
            text-decoration: none; /* Für Label-Buttons */
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width var(--transition-normal), height var(--transition-normal);
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-icon {
            background: transparent;
            color: var(--text-primary);
            padding: 0.5rem;
            border: 2px solid var(--bg-tertiary);
            gap: 0; /* Kein Gap für reine Icon-Buttons */
        }
        [data-theme="dark"] .btn-icon {
            border: 2px solid var(--bg-secondary);
            color: var(--text-primary);
        }


        .btn-icon:hover {
            background: var(--bg-tertiary);
        }
        .btn-icon.fa-spin {
            animation: fa-spin 1s linear;
        }

        /* Spezieller Map-Button-Stil */
        .btn-map {
            background: var(--success-gradient); /* Grün hinterlegt */
            color: white;
            padding: 0.85rem 1.2rem; /* Etwas größer */
            font-size: 1rem;
            height: calc(1.5em + 1.5rem + 4px); /* Gleiche Höhe wie form-control */
        }
        .btn-map i {
            font-size: 1.1rem; /* Icon etwas größer */
        }


        .btn-success {
            background: var(--success-gradient);
        }

        .btn-danger {
            background: var(--danger-gradient);
        }

        .btn-warning {
            background: var(--warning-gradient);
        }

        .btn-large {
            padding: 1rem 2rem;
            font-size: 1.1rem;
        }
        .btn-sm {
            padding: 0.25rem 0.75rem;
            font-size: 0.85rem;
        }


        /* Calendar Grid */
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
        }

        .calendar-day-header {
            text-align: center;
            font-weight: 600;
            color: var(--text-secondary);
            padding: 0.5rem;
        }

        .calendar-day {
            aspect-ratio: 1;
            background: var(--bg-primary);
            border: 2px solid transparent;
            border-radius: var(--radius-md);
            padding: 0.5rem;
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            overflow: hidden;
        }

        .calendar-day:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            background: var(--bg-tertiary);
        }

        .calendar-day.has-catch::after {
            content: '🐟';
            position: absolute;
            top: 3px; /* Etwas nach unten für größere Schrift */
            right: 3px; /* Etwas nach links für größere Schrift */
            font-size: 1.1rem; /* Größer gemacht */
            opacity: 0.9;
        }

        .calendar-day.has-angelgang {
            border: 2px solid #3498db; /* Blau für Angelgang */
        }
         .calendar-day.has-angelgang.has-catch { /* Wenn beide true sind */
            border: 2px solid #8e44ad; /* Lila für Angelgang mit Fang */
        }


        .calendar-day.today {
            background: var(--primary-gradient);
            color: white;
            font-weight: 600;
        }
        .calendar-day.today.has-angelgang {
            border-color: white;
        }
         .calendar-day.today.has-angelgang.has-catch {
            border-color: #f0e6f6;
        }


        .day-number {
            font-size: 0.9rem;
            font-weight: 500;
            align-self: flex-start;
        }

        .day-event-markers {
            position: absolute;
            bottom: 5px;
            left: 5px;
            display: flex;
            gap: 4px;
        }
        .event-marker {
            width: 10px; /* Größer gemacht */
            height: 10px; /* Größer gemacht */
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }
        .event-marker.planned-trip-marker {
            background-color: #e74c3c; /* Rot für geplante Trips */
        }
        .event-marker.angelgang-marker {
            background-color: #3498db; /* Blau für Angelgang */
        }
        .event-marker.angelgang-schneider-marker {
    background-color: brown; /* Braun für Angelgang (Schneider) */
}
        .event-marker.angelgang-catch-marker {
            background-color: #8e44ad; /* Lila für Angelgang mit Fang */
        }
        .calendar-legend {
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: var(--bg-tertiary);
            border-radius: var(--radius-md);
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            font-size: 0.9rem;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .legend-item .event-marker, .legend-item .legend-icon { /* .legend-icon für Fisch */
            flex-shrink: 0;
        }


        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 2000;
            animation: fadeIn var(--transition-normal);
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--bg-primary);
            border-radius: var(--radius-xl);
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 2rem;
            position: relative;
            animation: slideUp var(--transition-normal);
        }
        #tripPlanningModal .modal-content, #userEquipmentSetModal .modal-content { /* Auch für Ausrüstungs-Set Modal */
            max-width: 950px;
        }
        #catchModal .modal-content { /* Breiter für das Fangformular */
            max-width: 850px;
        }
        #catchLocationMapModal .modal-content { /* Für Universal-Karten-Modal */
            width: 95%;
            max-width: 1200px; /* Kann sehr breit sein */
            height: 90vh;      /* Sehr hoch */
            padding: 0; /* Kein internes Padding, da Header und Flexbox es regeln */
            display: flex;     /* Für internes Layout */
            flex-direction: column;
        }


        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--bg-tertiary);
        }
         /* Für Modals mit eigenem Padding-Handling */
        #catchLocationMapModal .modal-header {
            padding: 1rem;
            margin-bottom: 0; /* Wird durch Flexbox geregelt */
            border-bottom: 1px solid var(--bg-tertiary);
            flex-shrink: 0; /* Header soll nicht schrumpfen */
        }
        #catchLocationMapModal .modal-header h2 {
            font-size: 1.2rem;
        }
        #catchLocationMapModal .close-btn {
            font-size: 1.2rem; width: 30px; height: 30px;
        }


        .close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all var(--transition-fast);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        .close-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            transform: rotate(90deg);
        }

        /* Form Styles */
        .form-group {
            margin-bottom: 1.5rem;
        }
         .form-group.inline-checkboxes label { /* Für User Set Applicable Types */
            margin-right: 0.5rem;
            font-weight: normal;
        }
        .form-group.inline-checkboxes input[type="checkbox"] {
            margin-right: 0.25rem;
        }
        .inline-checkbox-container {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem 1rem;
        }


        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .form-label-sm { /* Kleinere Labels, z.B. im Kartenmodal */
            font-size: 0.9em;
            margin-bottom: 0.25rem;
        }

        .form-control {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid var(--bg-tertiary);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all var(--transition-fast);
            font-size: 1rem;
        }
        .form-control-sm { /* Kleinere Inputs, z.B. im Kartenmodal */
            padding: 0.5rem 0.75rem;
            font-size: 0.9rem;
        }

        [data-theme="dark"] .form-control {
             border: 2px solid var(--bg-primary);
        }


        .form-control:focus {
            outline: none;
            border-color: #3498db;
            background: var(--bg-primary);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        select.form-control {
            cursor: pointer;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        input[type="range"].form-control {
            padding: 0; /* Override default padding for range */
            height: auto; /* Allow browser default height for range */
        }

        /* Slider Input Group (NEU für Schieberegler) */
        .slider-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .slider-input-group .btn-icon { /* Buttons für +/- */
            padding: 0.5rem 0.7rem; /* Angepasste Größe */
        }
        .slider-input-group input[type="range"] { /* Der Slider selbst */
            flex-grow: 1;
        }


        /* Location Input Group */
        .location-input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center; /* Vertikale Zentrierung */
        }

        .location-input-group .form-control {
            flex: 1;
        }

        .location-btn { /* Standard GPS Button (nicht mehr verwendet für Angelgang) */
            padding: 0.75rem 1rem;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            height: calc(1.5em + 1.5rem + 4px);
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .location-btn:hover {
            transform: scale(1.05);
        }
        /* Angepasster Stil für Gewässer/Ort Info Anzeige */
        .location-display-control {
            flex-grow: 1;
            background-color: var(--bg-tertiary);
            min-height: calc(1.5em + 1.5rem + 4px); /* Höhe von form-control */
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-radius: var(--radius-md);
            border: 2px solid var(--bg-tertiary);
            cursor: pointer;
            color: var(--text-secondary); /* Standardtextfarbe */
            overflow: hidden; /* Verhindert Überlaufen von langem Text */
            text-overflow: ellipsis; /* Zeigt "..." an, wenn Text zu lang */
            white-space: nowrap; /* Verhindert Umbruch, damit ellipsis funktioniert */
        }
        .location-display-control strong {
            color: var(--text-primary); /* Hervorhebung */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .location-display-control span { /* Falls ein Span direkt innen ist */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: inline-block; /* Notwendig für text-overflow bei span */
            max-width: 100%;
        }
        [data-theme="dark"] .location-display-control {
            border: 2px solid var(--bg-primary);
        }


        /* Photo Upload Area */
        .photo-upload {
            border: 2px dashed var(--bg-tertiary);
            border-radius: var(--radius-md);
            padding: 2rem;
            text-align: center;
            transition: all var(--transition-fast);
            position: relative;
            overflow: hidden;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .photo-preview {
            margin-top: 1rem;
            text-align: center;
        }
        .photo-preview img {
            max-width: 100%;
            max-height: 250px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            display: none;
        }


        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: var(--radius-md);
            text-align: center;
            transition: all var(--transition-fast);
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Catch List */
        .catch-list {
            display: grid;
            gap: 1rem;
        }

        .catch-item {
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            padding: 1.5rem;
            display: flex;
            gap: 1.5rem;
            align-items: center;
            transition: all var(--transition-fast);
            cursor: pointer;
            position: relative;
        }

        .catch-item:hover {
            transform: translateX(4px);
            box-shadow: var(--shadow-md);
        }

        .catch-photo {
            width: 80px;
            height: 80px;
            border-radius: var(--radius-md);
            object-fit: cover;
            box-shadow: var(--shadow-sm);
        }

        .catch-details {
            flex: 1;
        }

        .catch-species {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.25rem;
        }

        .catch-info {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .catch-actions {
            display: flex;
            gap: 0.5rem;
        }

        /* Gewässer List (auch für Universal Map Modal) */
        .gewaesser-grid { /* Für Gewässer-Tab-Liste */
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        #catchMapGewaesserList { /* Für Universal Map Modal Liste */
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 0.5rem;
            max-height: calc(100% - 120px);
            overflow-y: auto;
        }

        /* Anpassung für Gewässer-Items im Gewässer-Tab für besseren Kontrast */
        #gewaesser-tab .gewaesser-item {
            background: var(--bg-primary); /* Sollte sich vom --bg-secondary des .card abheben */
            border: 1px solid var(--bg-tertiary);
            box-shadow: var(--shadow-sm);
        }
        [data-theme="dark"] #gewaesser-tab .gewaesser-item {
            background: var(--bg-tertiary); /* Im Darkmode ist primary zu dunkel, tertiary ist hier besser */
            border: 1px solid var(--bg-secondary);
        }


        .gewaesser-item { /* Basis für beide Listen */
            background: var(--bg-secondary); /* Standard für Listen in Modals */
            border-radius: var(--radius-md);
            padding: 1rem;
            cursor: pointer;
            transition: all var(--transition-fast);
        }
         #catchMapGewaesserList .gewaesser-item { /* Spezifisch für Kartenmodal-Liste */
            padding: 0.5rem 0.75rem;
            font-size: 0.9em;
            flex-shrink: 0;
            background: var(--bg-tertiary); /* Im Modal kann es tertiary sein für besseren Kontrast */
        }
        [data-theme="dark"] #catchMapGewaesserList .gewaesser-item {
            background: var(--bg-secondary);
        }

        #catchMapGewaesserList .gewaesser-item.selected-for-catch {
            background: var(--primary-gradient);
            color: white;
        }
        #catchMapGewaesserList .gewaesser-item.selected-for-catch .gewaesser-info span,
        #catchMapGewaesserList .gewaesser-item.selected-for-catch .gewaesser-name {
            color: white !important;
        }
        #catchMapGewaesserList .gewaesser-item.selected-for-catch .gewaesser-info span i {
             color: white !important;
        }




        .gewaesser-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .gewaesser-name {
            font-weight: 600;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }
         #catchMapGewaesserList .gewaesser-name {
            font-size: 1em;
            margin-bottom: 0.25rem;
        }


        .gewaesser-info {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
         #catchMapGewaesserList .gewaesser-info {
            font-size: 0.8em;
            grid-template-columns: 1fr;
        }
        #catchMapGewaesserList .gewaesser-info span i {
            margin-right: 0.3em;
            color: var(--text-secondary);
        }



        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--bg-tertiary);
            border-radius: 50%;
            border-top-color: #3498db;
            animation: spin 1s ease-in-out infinite;
        }

        .fa-spin {
            animation: fa-spin 1s infinite linear;
        }
        @keyframes fa-spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--primary-gradient);
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            transition: all var(--transition-fast);
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            box-shadow: var(--shadow-xl);
        }

        /* Pressure Trend Indicator */
        .pressure-trend {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.9rem;
        }

        .pressure-trend.rising i { color: #27ae60; }
        .pressure-trend.falling i { color: #e74c3c; }
        .pressure-trend.stable i { color: #f39c12; }


        /* Moon Phase Display in Header */
        .moon-phase {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: #e0e0e0;
            box-shadow: inset 2px -2px 5px rgba(0,0,0,0.2), inset -2px 2px 5px rgba(255,255,255,0.2);
            border: 1px solid #ccc;
        }



        /* Solunar Times */
        .solunar-times {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-top: 1rem;
        }

        .solunar-period {
            background: var(--bg-tertiary);
            padding: 0.75rem;
            border-radius: var(--radius-md);
            text-align: center;
        }

        .solunar-period.major {
            border: 2px solid #3498db;
        }
         .solunar-period.minor {
            border: 2px solid #f1c40f;
        }

        .solunar-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: block;
        }

        .solunar-time {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Factor Breakdown for Probability Details */
        .factor-breakdown {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            font-size: 0.9rem;
        }

        .factor-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--bg-secondary);
        }
        [data-theme="dark"] .factor-item {
            border-bottom: 1px solid var(--bg-primary);
        }


        .factor-item:last-child {
            border-bottom: none;
        }

        .factor-score {
            font-weight: 600;
        }

        .factor-score.positive { color: #27ae60; }
        .factor-score.negative { color: #e74c3c; }
        .factor-score.neutral { color: #f39c12; }

        /* Trip Planning Specific Styles */
        .participant-field {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.75rem; /* Etwas weniger als form-group */
        }
        .participant-color {
            min-width:50px !important; /* Wichtig für Konsistenz */
            padding: 0.25rem !important;
            height: calc(1.5em + 1.5rem + 4px) !important; /* Gleich hoch wie Text Input */
        }
        .equipment-item-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.75rem; /* Mehr Padding */
            border-radius: var(--radius-md); /* Größerer Radius */
            transition: background-color var(--transition-fast), box-shadow var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }
        .equipment-item-row label {
            flex-grow: 1;
            cursor: pointer;
            transition: color var(--transition-fast); /* Für Textfarbwechsel */
        }
        .equipment-item-row:hover {
            box-shadow: var(--shadow-md);
        }
        .equipment-item-row input[type="checkbox"] {
            margin-right: 0.75rem;
            transform: scale(1.3);
            cursor: pointer;
        }
        .equipment-assignee {
            max-width: 180px;
            height: auto !important; /* Override form-control */
            padding: 0.35rem 0.6rem !important; /* Override form-control */
            font-size: 0.9rem;
            transition: color var(--transition-fast), background-color var(--transition-fast);
        }
        /* Styles für den Einstellungs-Tab, Angelarten und Equipment Katalog */
        .settings-item-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: var(--radius-md);
            margin-bottom: 0.5rem;
            box-shadow: var(--shadow-sm);
        }
        .settings-item-row span {
            font-weight: 500;
        }
        .settings-item-row .item-details {
            font-size: 0.85em;
            color: var(--text-secondary);
            display: block;
            margin-top: 0.2rem;
        }
         /* Ausrüstungs-Set Items im Modal */
        .user-equipment-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem;
            border-bottom: 1px solid var(--bg-tertiary);
        }
        .user-equipment-item:last-child {
            border-bottom: none;
        }
        .user-equipment-item select {
            flex-grow: 1;
        }

        /* Connection Status */
        .connection-status {
            background: var(--danger-gradient);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            display: none; /* Default state, JS controls visibility */
            animation: slideDownFade 0.3s ease-out;
            align-self: center;
            margin-left: 1rem;
        }

        .connection-status.offline {
            display: block; /* Show when offline */
        }

        .connection-status.online {
            background: var(--success-gradient);
            display: block; /* Show briefly when online */
        }


        /* Print Styles */
        @media print {
            body { background: white !important; color: #333 !important; }
            header, .nav-tabs, .theme-toggle, .water-bg, .no-print { display: none !important; }
            .container, .card, .modal-content {
                box-shadow: none !important;
                border: 1px solid #ccc !important;
                padding: 0.5rem !important;
                margin: 0.5rem 0 !important;
                background: white !important;
            }
            .modal {
                position: static !important;
                display: block !important; /* Modals im Druck anzeigen */
                background: transparent !important;
                backdrop-filter: none !important;
            }
            .modal-content { /* Speziell für den Trip Plan PDF */
                 width: 100% !important; max-width: 100% !important;
                 max-height: none !important; overflow: visible !important;
            }
            h1, h2, h3, p, li, td, th { color: #333 !important; }
            .btn { display:none; } /* Buttons im Druck ausblenden, es sei denn, sie haben eine .print-show Klasse */
            input[type="checkbox"] { /* Checkboxen im Druck besser darstellen */
                appearance: none; -webkit-appearance: none; -moz-appearance: none;
                width: 1em; height: 1em; border: 1px solid #555; vertical-align: middle;
                position: relative;
            }
            input[type="checkbox"]:checked::before {
                content: '\2713'; /* Häkchen */
                position: absolute; top: -0.1em; left: 0.1em; font-size: 1em; color: #333;
            }
            .connection-status { display: none !important; }
        }

        /* Mobile Optimization */
        @media (max-width: 768px) {
    /* Header minimal und dezent */
    header {
        padding: 0.75rem 1rem;
    }

    .header-content {
        flex-direction: column;
        text-align: center;
        gap: 0.5rem;
        align-items: center;
    }

    /* App-Name dezent aber lesbar */
    h1 {
        font-size: 1.4rem;
        margin: 0;
        font-weight: 600;
        opacity: 0.95;
    }

    /* Weather Widget: Immer sichtbar, anpassende Größen */
    .weather-widget {
        width: auto;
        max-width: 100%;
        justify-content: center;
        flex-wrap: nowrap;
        padding: 0.4rem 1rem;
        gap: 1rem;
        font-size: 0.85rem;
        border-radius: var(--radius-lg);
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(8px);
        border: 1px solid rgba(255,255,255,0.15);
        overflow-x: auto; /* Falls zu breit, horizontal scrollen */
    }

    .weather-item {
        gap: 0.4rem;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        min-width: max-content;
    }

    .weather-item i {
        font-size: 1rem;
        opacity: 0.9;
    }

    .weather-item span {
        font-size: 0.85rem;
        font-weight: 500;
    }

    .pressure-trend {
        display: inline-flex;
        align-items: center;
        gap: 0.2rem;
    }

    .pressure-trend i {
        font-size: 0.8rem;
    }
}

/* Für kleinere Bildschirme - kleinere Schrift, aber alles sichtbar */
@media (max-width: 480px) {
    header {
        padding: 0.6rem 0.8rem;
    }

    h1 {
        font-size: 1.25rem;
    }

    .weather-widget {
        padding: 0.35rem 0.8rem;
        gap: 0.7rem; /* Etwas engere Abstände */
        font-size: 0.8rem;
    }

    .weather-item {
        gap: 0.3rem;
    }

    .weather-item i {
        font-size: 0.9rem;
    }

    .weather-item span {
        font-size: 0.8rem;
    }

    .pressure-trend i {
        font-size: 0.7rem;
    }
}

/* Für sehr kleine Bildschirme - noch kleinere Schrift */
@media (max-width: 380px) {
    h1 {
        font-size: 1.1rem;
    }

    .weather-widget {
        padding: 0.3rem 0.6rem;
        gap: 0.5rem; /* Noch engere Abstände */
        font-size: 0.75rem;
    }

    .weather-item {
        gap: 0.25rem;
    }

    .weather-item i {
        font-size: 0.8rem;
    }

    .weather-item span {
        font-size: 0.75rem;
    }

    .pressure-trend i {
        font-size: 0.65rem;
    }
}

/* Für extrem kleine Bildschirme - minimale Schrift */
@media (max-width: 320px) {
    h1 {
        font-size: 1rem;
    }

    .weather-widget {
        padding: 0.25rem 0.5rem;
        gap: 0.4rem;
        font-size: 0.7rem;
    }

    .weather-item {
        gap: 0.2rem;
    }

    .weather-item i {
        font-size: 0.75rem;
    }

    .weather-item span {
        font-size: 0.7rem;
    }

    .pressure-trend i {
        font-size: 0.6rem;
    }
}

    /* Pressure Trend Icon auch kleiner */
    .pressure-trend i {
        font-size: 0.7rem;
    }
}

            .dashboard-grid {
                grid-template-columns: 1fr;
            }

            .calendar-grid {
                gap: 0.25rem;
            }

            .calendar-day {
                font-size: 0.8rem;
                padding: 0.25rem;
            }
            .day-number {
                font-size: 0.75rem;
            }
            .day-event-markers {
                bottom: 2px;
                left: 2px;
                gap: 2px; /* Etwas mehr Platz */
            }
            .event-marker {
                width: 6px; /* Etwas größer auf mobil */
                height: 6px; /* Etwas größer auf mobil */
            }
            .calendar-day.has-catch::after {
                font-size: 0.8rem; /* Etwas größer auf mobil */
                top: 1px;
                right: 1px;
            }
            .calendar-legend { font-size: 0.8rem; gap: 0.5rem; }


            .modal-content {
                padding: 1rem;
                width: 95%; /* Generell etwas mehr Platz auf Mobile */
                max-height: 95vh;
            }
            #catchModal .modal-content {
                padding: 1.5rem 1rem; /* Mehr Padding oben/unten für Fangformular */
            }
             #catchLocationMapModal .modal-content {
                width: 100%; /* Volle Breite für Karte */
                height: 100%;  /* Volle Höhe für Karte */
                max-width: 100%;
                max-height: 100%;
                border-radius: 0; /* Keine Radien für Vollbild-Modal */
            }
             #catchLocationMapModal .modal-header {
                padding: 0.75rem;
            }
             #catchLocationMapModal #catchMapSidebar {
                width: 180px; /* Schmalere Sidebar auf Mobile */
                padding: 0.5rem;
                flex-shrink: 0; /* Verhindert Schrumpfen der Sidebar */
                overflow-y: auto; /* Allow sidebar to scroll its own content */
                 /* Einklapp-Logik wird in JS gesteuert, display: none; wenn eingeklappt */
            }
            #catchLocationMapModal #catchMapSidebar.collapsed {
                display: none;
            }

            #catchLocationMapModal #catchMapSidebar h4 {
                font-size: 0.9em;
            }
            #catchLocationMapModal #catchMapGewaesserList .gewaesser-item {
                padding: 0.4rem 0.6rem;
                font-size: 0.85em;
            }
            #catchLocationMapModal #catchMapInstructions {
                font-size: 0.7em;
                bottom: 5px; left: 5px;
            }


             #tripPlanningModal .modal-content, #userEquipmentSetModal .modal-content {
                max-width: 95%;
                padding: 1rem; /* Konsistent mit anderen Modals auf Mobile */
            }
            #tripPlanningModal .participant-field {
                flex-wrap: wrap; /* Erlaube Umbruch für Teilnehmerfelder */
            }
            #tripPlanningModal .participant-name {
                flex-basis: 100%; /* Volle Breite für Namen */
                margin-bottom: 0.5rem;
            }
            #tripPlanningModal .participant-color {
                flex-grow: 1; /* Farbe nimmt Restplatz */
            }
            #tripPlanningModal .equipment-item-row {
                flex-wrap: wrap;
            }
            #tripPlanningModal .equipment-item-row label {
                flex-basis: 100%;
                margin-bottom: 0.5rem;
            }
            #tripPlanningModal .equipment-assignee {
                max-width: none; /* Volle Breite für Zuweisung auf Mobile */
                width: 100%;
            }



            .nav-tabs {
                justify-content: flex-start;
            }

            .angelgang-info {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Water Animation Background -->
    <div class="water-bg"></div>

    <!-- Header -->
    <header>
        <div class="header-content">
            <h1><i class="fas fa-fish"></i> Dein Angelfreund </h1>
            <div class="weather-widget" id="weatherWidget">
                <div class="weather-item">
                    <i class="fas fa-temperature-high"></i>
                    <span id="temperature">--°C</span>
                </div>
                <div class="weather-item">
                    <i class="fas fa-compress-arrows-alt"></i>
                    <span id="pressure">-- hPa</span>
                    <span class="pressure-trend" id="pressureTrend"><i class="fas fa-minus"></i></span>
                </div>
                <div class="weather-item">
                    <i class="fas fa-wind"></i>
                    <span id="wind">-- km/h</span>
                </div>
                <div class="weather-item">
                    <i class="fas fa-moon"></i>
                    <span id="moonPhase">--</span>
                </div>
            </div>
            <!-- Connection Status Indicator -->
            <div class="connection-status" id="connectionStatus">
                <i class="fas fa-wifi"></i> Offline
            </div>
            <button id="installPwaButton" class="btn" style="display: none; margin-left: 1rem;">
                <i class="fas fa-download"></i> App installieren
            </button>
        </div>
    </header>

    <!-- Navigation Tabs -->
    <div class="nav-tabs">
        <button class="nav-tab active" onclick="switchTab('dashboard', event)">
            <i class="fas fa-tachometer-alt"></i> Dashboard
        </button>
        <button class="nav-tab" onclick="switchTab('angelgang', event)">
            <i class="fas fa-play-circle"></i> Angelgang
        </button>
        <button class="nav-tab" onclick="switchTab('calendar', event)">
            <i class="fas fa-calendar-alt"></i> Kalender
        </button>
        <button class="nav-tab" onclick="switchTab('gewaesser', event)">
            <i class="fas fa-water"></i> Gewässer
        </button>
        <button class="nav-tab" onclick="switchTab('statistics', event)">
            <i class="fas fa-chart-bar"></i> Statistiken
        </button>
        <button class="nav-tab" onclick="switchTab('settings', event)">
            <i class="fas fa-cog"></i> Einstellungen
        </button>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Dashboard Tab -->
        <div class="tab-content active" id="dashboard-tab">
            <div class="dashboard-grid">
                <!-- Current Angelgang Status -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Aktueller Angelgang</h2>
                    </div>
                    <div class="angelgang-status">
                        <div id="angelgangStatusDisplay">
                            <p>Kein aktiver Angelgang</p>
                            <button class="btn btn-success btn-large" onclick="startAngelgangWizard()">
                                <i class="fas fa-play"></i> Neuen Angelgang starten
                            </button>
                        </div>
                    </div>
                </div>
                <!-- Bite Probability Card -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Bisswahrscheinlichkeit Heute</h2>
                        <button class="btn btn-icon" onclick="refreshProbabilities(event)">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                    <div class="probability-grid" id="probabilityGrid">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <!-- Solunar Times Card -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Solunar Zeiten</h2>
                        <div class="moon-phase" id="moonPhaseVisual">
                             <!-- JS will populate this -->
                        </div>
                    </div>
                    <div class="solunar-times" id="solunarTimes">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <!-- Quick Stats Card -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Fangstatistik</h2>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-number" id="totalCatches">0</div>
                            <div class="stat-label">Gesamt Fänge</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="thisMonth">0</div>
                            <div class="stat-label">Diesen Monat</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="bestFish">-</div>
                            <div class="stat-label">Häufigste Art</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Catches -->
            <div class="card" style="margin-top: 2rem;">
                <div class="card-header">
                    <h2 class="card-title">Aktuelle Fänge</h2>
                    <button class="btn" onclick="openCatchModal()">
                        <i class="fas fa-plus"></i> Neuer Fang
                    </button>
                </div>
                <div class="catch-list" id="catchList">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Angelgang Tab -->
        <div class="tab-content" id="angelgang-tab">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Angelgang Management</h2>
                </div>
                <div id="angelgangContent">
                    <!-- Content will be dynamically populated based on angelgang state -->
                </div>
            </div>

            <!-- Angelgang History -->
            <div class="card" style="margin-top: 2rem;">
                <div class="card-header">
                    <h2 class="card-title">Angelgang Historie</h2>
                </div>
                <div id="angelgangHistory" class="catch-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Calendar Tab -->
        <div class="tab-content" id="calendar-tab">
            <div class="calendar-container">
                <div class="calendar-header">
                    <h2 id="currentMonthYear">Januar 2024</h2>
                    <div class="calendar-nav">
                        <button class="btn btn-icon" onclick="previousMonth()">
                            <i class="fas fa-chevron-left"></i>
                        </button>
                        <button class="btn" onclick="goToToday()">Heute</button>
                        <button class="btn btn-icon" onclick="nextMonth()">
                            <i class="fas fa-chevron-right"></i>
                        </button>
                    </div>
                </div>
                <div class="calendar-grid" id="calendarGrid">
                    <!-- Dynamically populated -->
                </div>
                <!-- Kalenderlegende -->
                <div class="calendar-legend" id="calendarLegend">
                    <div class="legend-item"><span class="event-marker planned-trip-marker"></span> Geplanter Trip</div>
                    <div class="legend-item"><span class="event-marker angelgang-marker"></span> Angelgang</div>
                    <div class="legend-item"><span class="event-marker angelgang-catch-marker"></span> Angelgang mit Fang</div>
                    <div class="legend-item"><span class="legend-icon" style="font-size: 1.1rem;">🐟</span> Fang (ohne Angelgang)</div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 2rem;">
                <button class="btn btn-large" onclick="openTripPlanningModal(null, null)">
                    <i class="fas fa-calendar-plus"></i> Neuen Trip planen
                </button>
            </div>
        </div>

        <!-- Gewässer Tab -->
        <div class="tab-content" id="gewaesser-tab">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Gewässerverwaltung</h2>
                    <button class="btn" onclick="openUniversalMapForGewaesserManagement()">
                        <i class="fas fa-map-marked-alt"></i> Gewässer auf Karte verwalten
                    </button>
                </div>
                <!-- Alte Kartenanzeige, kann später durch die Universal-Karte ersetzt oder stark modifiziert werden -->
                <div id="gewaesserMapContainer" style="display:none;"> <!-- Vorerst ausblenden, da Universal-Karte genutzt wird -->
                    <div class="location-search-bar">
                        <input type="text" class="form-control" id="gewaesserLocationSearch" placeholder="Ort suchen...">
                        <button class="btn" onclick="searchGewaesserLocation()">
                            <i class="fas fa-search"></i>
                        </button>
                         <button class="btn btn-icon" onclick="getCurrentPositionForGewaesserMap()" title="Meine Position auf Karte anzeigen">
                            <i class="fas fa-crosshairs"></i>
                        </button>
                    </div>
                    <div id="gewaesserMap"></div>
                </div>
                <p style="margin-top: 1rem; color: var(--text-secondary);">
                    Nutzen Sie den Button "Gewässer auf Karte verwalten", um Gewässer anzuzeigen, neue anzulegen oder bestehende zu bearbeiten. Alternativ können Sie auch <button class="btn btn-sm" onclick="openGewaesserModal()">hier manuell anlegen</button>.
                </p>
                <div class="gewaesser-grid" id="gewaesserList">
                    <!-- Dynamically populated, dient jetzt mehr als reine Auflistung, Bearbeitung über Karte -->
                </div>
            </div>
        </div>

        <!-- Statistics Tab -->
        <div class="tab-content" id="statistics-tab">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Detaillierte Statistiken</h2>
                </div>
                <div id="statisticsContent">
                    <!-- Detailed statistics will be shown here -->
                </div>
            </div>
        </div>

        <!-- Settings Tab -->
        <div class="tab-content" id="settings-tab">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Einstellungen</h2>
                </div>
                <div id="settingsContent">
                    <div class="form-group">
                        <label class="form-label" for="apiKeyInput">OpenWeatherMap API Key</label>
                        <input type="text" class="form-control" id="apiKeyInput" placeholder="Ihr API Key hier einfügen">
                        <button class="btn" onclick="saveApiKey()" style="margin-top: 0.5rem;">
                            <i class="fas fa-save"></i> API Key speichern
                        </button>
                        <p id="apiKeyStatus" style="font-size: 0.9rem; margin-top: 0.5rem;"></p>
                    </div>
                    <hr style="margin: 1.5rem 0;">
                     <div class="form-group">
                        <label class="form-label">Angelarten verwalten</label>
                        <div id="fishingTypesSettingsContainer" style="display:flex; flex-direction: column; gap: 0.5rem;"></div>
                        <div style="display:flex; gap:0.5rem; margin-top:0.5rem;">
                            <input type="text" class="form-control" id="newFishingTypeSettingInput" placeholder="Neue Angelart">
                            <button type="button" class="btn btn-icon" onclick="addFishingTypeFromSettings()"><i class="fas fa-plus"></i></button>
                        </div>
                    </div>
                    <hr style="margin: 1.5rem 0;">
                    <div class="form-group">
                        <label class="form-label">Packlisten-Katalog verwalten</label>
                        <div id="equipmentCatalogSettingsContainer" style="max-height: 300px; overflow-y:auto; border: 1px solid var(--bg-tertiary); padding:1rem; border-radius:var(--radius-md);"></div>
                        <div style="margin-top:1rem; display:grid; grid-template-columns: 1fr auto auto; gap:0.5rem;">
                            <input type="text" class="form-control" id="newEquipmentCatalogNameSettingInput" placeholder="Neuer Gegenstand">
                            <select class="form-control" id="newEquipmentCatalogCategorySettingSelect">
                                <!-- Kategorien (Angelarten) werden hier gefüllt -->
                            </select>
                            <button type="button" class="btn btn-icon" onclick="addEquipmentCatalogItemFromSettings()"><i class="fas fa-plus"></i></button>
                        </div>
                    </div>
                     <hr style="margin: 1.5rem 0;">
                    <div class="form-group">
                        <label class="form-label">Meine Ausrüstungs-Sets</label>
                        <div id="userEquipmentSetsContainer">
                            <!-- Hier werden die gespeicherten Sets angezeigt -->
                            <p style="color:var(--text-secondary);">Noch keine eigenen Sets erstellt.</p>
                        </div>
                        <button class="btn btn-sm" onclick="openUserEquipmentSetModal()" style="margin-top:0.5rem;">
                            <i class="fas fa-plus"></i> Neues Set erstellen
                        </button>
                    </div>
                    <hr style="margin: 2rem 0;">
                    <div class="form-group">
                        <label class="form-label">Daten Exportieren</label>
                        <button class="btn" onclick="exportData()">
                            <i class="fas fa-file-export"></i> Alle Daten als JSON exportieren
                        </button>
                    </div>
                    <hr style="margin: 2rem 0;">
                    <div class="form-group">
                        <label class="form-label" for="importFile">Daten Importieren (JSON)</label>
                        <input type="file" class="form-control" id="importFile" accept=".json">
                        <button class="btn btn-warning" onclick="importData()" style="margin-top: 0.5rem;">
                            <i class="fas fa-file-import"></i> Daten importieren
                        </button>
                         <p style="font-size:0.8rem; color: var(--text-secondary); margin-top:0.5rem;">Achtung: Bestehende Daten können überschrieben werden.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <!-- Angelgang Start Modal -->
    <div class="modal" id="angelgangModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Neuen Angelgang starten</h2>
                <button class="close-btn" onclick="closeAngelgangModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="angelgangForm">
                <div class="form-group">
                    <label class="form-label" for="targetFish">Zielfisch</label>
                    <select class="form-control" id="targetFish" required>
                        <option value="">Bitte wählen...</option>
                        <option value="pike">Hecht</option>
                        <option value="zander">Zander</option>
                        <option value="perch">Barsch</option>
                        <option value="eel">Aal</option>
                        <option value="carp">Karpfen</option>
                        <option value="trout">Forelle</option>
                        <option value="tench">Schleie</option>
                        <option value="multiple">Mehrere Arten</option>
                    </select>
                </div>

                <div class="form-group">
                    <span class="form-label">Gewässer & Angelplatz</span>
                    <div class="location-input-group">
                        <div id="selectedAngelgangGewaesserInfo" class="location-display-control"
                             onclick="openUniversalMapModal('selectGewasserForAngelgang', 'selectedGewaesserHidden', 'angelgangGewaesserCoordsStore', 'updateSelectedAngelgangGewaesserInfo')"
                             title="Ausgewähltes Gewässer und spezifischer Angelplatz">
                            <span style="color: var(--text-secondary);">Gewässer/Ort auf Karte wählen</span>
                        </div>
                        <button type="button" class="btn btn-map"
                                onclick="openUniversalMapModal('selectGewasserForAngelgang', 'selectedGewaesserHidden', 'angelgangGewaesserCoordsStore', 'updateSelectedAngelgangGewaesserInfo')"
                                title="Gewässer auf Karte auswählen/neues anlegen">
                            <i class="fas fa-map-marked-alt"></i>
                        </button>
                    </div>
                    <input type="hidden" id="selectedGewaesserHidden"> <!-- Hält die ID des ausgewählten Gewässers -->
                    <input type="hidden" id="angelgangGewaesserCoordsStore"> <!-- Hält die spezifischen Koordinaten des Angelplatzes am Gewässer -->
                </div>


                <div class="form-group">
                    <label class="form-label" for="fishingMethod">Angelmethode</label>
                    <select class="form-control" id="fishingMethod" required onchange="populateAngelgangEquipmentSetSelect(this.value)">
                        <option value="">Bitte wählen...</option>
                        <!-- Wird durch populateAllFishingTypeSelects gefüllt -->
                    </select>
                </div>
                 <div class="form-group" id="angelgangEquipmentSetGroup" style="display:none;"> <!-- Wird sichtbar, wenn Angelmethode gewählt -->
                    <label class="form-label" for="angelgangEquipmentSet">Ausrüstungs-Set (optional)</label>
                    <select class="form-control" id="angelgangEquipmentSet" onchange="applyAngelgangEquipmentSet(this.value)">
                        <option value="">Kein Set / Manuell</option>
                        <!-- Wird dynamisch gefüllt -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="equipment">Ausrüstung (Notizen)</label>
                    <textarea class="form-control" id="equipment" rows="3" placeholder="Rute, Rolle, Schnur, Köder..."></textarea>
                </div>

                <div class="form-group">
                    <label class="form-label" for="plannedDurationSlider">Geplante Dauer: <span id="plannedDurationValueDisplay">4</span> Std.</label>
                    <div class="slider-input-group">
                        <button type="button" class="btn btn-icon btn-sm" onclick="decrementPlannedDuration()" aria-label="Dauer um 1 Std. verringern">-</button>
                        <input type="range" class="form-control" id="plannedDurationSlider" min="1" max="24" step="1" value="4"
                               oninput="updatePlannedDurationDisplay(this.value);">
                        <button type="button" class="btn btn-icon btn-sm" onclick="incrementPlannedDuration()" aria-label="Dauer um 1 Std. erhöhen">+</button>
                    </div>
                    <input type="hidden" id="plannedDuration" name="plannedDuration" value="4">
                </div>

                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" class="btn btn-icon" onclick="closeAngelgangModal()">Abbrechen</button>
                    <button type="submit" class="btn btn-success">
                        <i class="fas fa-play"></i> Angelgang starten
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Catch Entry Modal (ÜBERARBEITET mit +/- Buttons) -->
    <div class="modal" id="catchModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="catchModalTitle">Fang dokumentieren</h2>
                <button class="close-btn" onclick="closeCatchModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="catchForm">
                <input type="hidden" id="editingCatchIdStore">

                <div class="form-group">
                    <label class="form-label" for="catchDate">Datum & Zeit des Fangs</label>
                    <input type="datetime-local" class="form-control" id="catchDate" required>
                </div>

                <div class="form-group">
                    <label class="form-label" for="fishSpecies">Fischart</label>
                    <select class="form-control" id="fishSpecies" required onchange="toggleOtherSpeciesInput(this.value)">
                        <option value="">Bitte wählen...</option>
                        <option value="pike">Hecht</option>
                        <option value="zander">Zander</option>
                        <option value="perch">Barsch</option>
                        <option value="eel">Aal</option>
                        <option value="carp">Karpfen</option>
                        <option value="trout">Forelle</option>
                        <option value="tench">Schleie</option>
                        <option value="other_species">Andere Art</option>
                    </select>
                    <input type="text" class="form-control" id="fishSpeciesOther" placeholder="Andere Art spezifizieren" style="display:none; margin-top:0.5rem;">
                </div>

                <div class="form-group">
                    <label class="form-label" for="fishSizeSlider">Größe: <span id="fishSizeValueDisplay">10.0</span> cm</label>
                    <div class="slider-input-group">
                        <button type="button" class="btn btn-icon btn-sm" onclick="decrementFishSize()">-</button>
                        <input type="range" class="form-control" id="fishSizeSlider" min="0.1" max="300" step="0.1" value="10"
                               oninput="updateFishSizeDisplay(this.value);" style="flex-grow: 1;">
                        <button type="button" class="btn btn-icon btn-sm" onclick="incrementFishSize()">+</button>
                    </div>
                    <input type="hidden" id="fishSize" name="fishSize" value="10">
                </div>


                <div class="form-group">
                    <label class="form-label" for="fishWeightSlider">Gewicht: <span id="fishWeightValueDisplay">500</span> g</label>
                     <div class="slider-input-group">
                        <button type="button" class="btn btn-icon btn-sm" onclick="decrementFishWeight()">-</button>
                        <input type="range" class="form-control" id="fishWeightSlider" min="1" max="50000" step="1" value="500"
                               oninput="updateFishWeightDisplay(this.value);">
                        <button type="button" class="btn btn-icon btn-sm" onclick="incrementFishWeight()">+</button>
                    </div>
                    <input type="hidden" id="fishWeight" name="fishWeight" value="500">
                </div>

               <div class="form-group">
                    <span class="form-label">Gewässer & Fangort</span>
                    <div class="location-input-group">
                        <div id="selectedCatchGewaesserInfo" class="location-display-control"
                             onclick="openUniversalMapModal('selectCatchLocation', 'catchGewaesserIdStore', 'catchLocationCoordsStore', 'updateSelectedCatchGewaesserInfo')"
                             title="Ausgewähltes Gewässer und Koordinaten">
                            <span style="color: var(--text-secondary);">Kein Gewässer/Ort ausgewählt</span>
                        </div>
                        <button type="button" class="btn btn-map"
                                onclick="openUniversalMapModal('selectCatchLocation', 'catchGewaesserIdStore', 'catchLocationCoordsStore', 'updateSelectedCatchGewaesserInfo')"
                                title="Gewässer auf Karte auswählen/neuen Fangort markieren">
                            <i class="fas fa-map-marked-alt"></i>
                        </button>
                    </div>
                    <input type="hidden" id="catchGewaesserIdStore">
                    <input type="hidden" id="catchLocationCoordsStore">
                </div>

                <div class="form-group">
                    <label class="form-label" for="catchFishingMethod">Angelmethode</label>
                    <select class="form-control" id="catchFishingMethod" onchange="updateCatchBaitOptions(this.value)">
                        <option value="">Bitte wählen...</option>
                        <!-- Dynamisch gefüllt -->
                    </select>
                </div>

                <div class="form-group">
                    <label class="form-label" for="catchBait">Köder</label>
                    <select class="form-control" id="catchBait" onchange="toggleOtherBaitInput(this.value)">
                        <option value="">Erst Angelmethode wählen...</option>
                    </select>
                    <input type="text" class="form-control" id="catchBaitOther" placeholder="Anderen Köder spezifizieren" style="display:none; margin-top:0.5rem;">
                </div>

                <div class="form-group">
                    <label class="form-label">Foto</label>
                    <div style="display: flex; gap: 1rem; margin-bottom: 0.5rem;">
                        <label for="catchPhotoFileDevice" class="btn" style="flex: 1;">
                            <i class="fas fa-upload"></i> Von Gerät
                        </label>
                        <input type="file" id="catchPhotoFileDevice" accept="image/*" onchange="previewCatchPhoto(event)" style="display:none;">

                        <label for="catchPhotoFileCamera" class="btn" style="flex: 1;">
                            <i class="fas fa-camera-retro"></i> Kamera nutzen
                        </label>
                        <input type="file" id="catchPhotoFileCamera" accept="image/*" capture="environment" onchange="previewCatchPhoto(event)" style="display:none;">
                    </div>
                    <div class="photo-upload" id="catchPhotoUploadArea">
                        <p><i class="fas fa-image" style="font-size:1.5rem; margin-bottom:0.5rem;"></i><br>Kein Foto ausgewählt.</p>
                    </div>
                    <div class="photo-preview" id="catchPhotoPreviewContainer">
                        <img id="catchPreviewImage" alt="Fangfoto Vorschau" src="">
                        <button type="button" id="removeCatchPhotoBtn" class="btn btn-danger btn-sm" style="display:none; margin-top:0.5rem;" onclick="removeCatchPhotoPreview()">Foto entfernen</button>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label" for="catchNotes">Notizen</label>
                    <textarea class="form-control" id="catchNotes" rows="3" placeholder="Besondere Umstände, Story zum Fang..."></textarea>
                </div>
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" class="btn btn-icon" onclick="closeCatchModal()">Abbrechen</button>
                    <button type="submit" class="btn btn-success">
                        <i class="fas fa-save"></i> Fang speichern
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Universal Map Modal (ehemals CatchLocationMapModal) -->
    <div class="modal" id="catchLocationMapModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="catchLocationMapModalTitle">Kartenansicht</h2>
                <div>
                     <button class="btn btn-icon btn-sm" onclick="toggleUniversalMapSidebar()" title="Sidebar ein-/ausklappen" style="margin-right: 0.5rem;">
                        <i class="fas fa-bars"></i>
                    </button>
                    <button class="btn btn-success btn-sm" onclick="saveCatchLocationFromMap()">
                        <i class="fas fa-check"></i> Auswahl übernehmen
                    </button>
                    <button class="close-btn" onclick="closeCatchLocationMapModal()">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>

            <div style="display: flex; flex-grow: 1; overflow: hidden;">
                <!-- Sidebar (einklappbar) -->
                <div id="catchMapSidebar" style="width: 250px; background: var(--bg-secondary); padding: 1rem; overflow-y: auto; border-right: 1px solid var(--bg-tertiary); display: flex; flex-direction: column;">
                    <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                            <span>Gespeicherte Gewässer</span>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="collapsible-content open"> <!-- Standardmäßig offen -->
                             <div id="catchMapGewaesserList" style="flex-grow:1; overflow-y:auto; margin-bottom:1rem;">
                                <!-- Dynamisch gefüllt -->
                            </div>
                        </div>
                    </div>
                     <div class="collapsible-section">
                        <div class="collapsible-header" onclick="toggleCollapsible(this)">
                             <span id="newSpotSectionTitle">Neuen Spot/Gewässer anlegen</span>
                            <i class="fas fa-chevron-down"></i>
                        </div>
                        <div class="collapsible-content"> <!-- Standardmäßig zu -->
                            <div id="newSpotNameInputContainer">
                                <div class="form-group" style="margin-bottom:0.5rem;">
                                    <label for="newSpotNameInput" class="form-label form-label-sm" id="newSpotNameLabel">Name:</label>
                                    <input type="text" id="newSpotNameInput" class="form-control form-control-sm" placeholder="Z.B. Buhne 5">
                                </div>
                                 <!-- Optional: Typ-Auswahl für neues Gewässer direkt hier -->
                                <div class="form-group" style="margin-bottom:0.5rem; display:none;" id="newGewaesserTypeContainer_universalMap">
                                    <label for="newGewaesserType_universalMap" class="form-label form-label-sm">Typ:</label>
                                    <select id="newGewaesserType_universalMap" class="form-control form-control-sm">
                                        <option value="spot">Spot (Angelplatz)</option>
                                        <option value="lake">See</option>
                                        <option value="river">Fluss</option>
                                        <option value="pond">Teich</option>
                                        <option value="reservoir">Talsperre</option>
                                        <option value="canal">Kanal</option>
                                        <option value="stream">Bach</option>
                                        <option value="other">Anderer Typ</option>
                                    </select>
                                </div>
                            </div>
                            <p style="font-size:0.8em; color: var(--text-secondary); margin-top:0.5rem;" id="newSpotInstructions">
                                Markieren Sie einen Punkt auf der Karte.
                            </p>
                        </div>
                    </div>
                </div>
                <!-- Kartenbereich -->
                <div style="flex-grow: 1; display: flex; flex-direction: column; position: relative;">
                    <div style="padding: 0.5rem 1rem; background: var(--bg-primary); border-bottom: 1px solid var(--bg-tertiary); display:flex; gap:0.5rem; align-items:center; flex-shrink:0;">
                        <input type="text" class="form-control form-control-sm" id="catchMapLocationSearchInput" placeholder="Ort suchen..." style="flex-grow:1;">
                        <button class="btn btn-sm btn-icon" onclick="searchCatchMapLocation()">
                            <i class="fas fa-search"></i>
                        </button>
                        <button class="btn btn-sm btn-icon" onclick="useCurrentGPSForCatchMap()" title="Aktuelle GPS Position als Mittelpunkt">
                            <i class="fas fa-crosshairs"></i>
                        </button>
                    </div>
                    <div id="catchLeafletMapContainer" style="flex-grow: 1;">
                         <div id="catchLeafletMap"></div>
                    </div>
                    <div id="catchMapInstructions" style="position:absolute; bottom:10px; left:10px; background:rgba(var(--bg-primary-rgb),0.9); color: var(--text-primary); padding:5px 10px; border-radius:var(--radius-sm); font-size:0.8em; box-shadow: var(--shadow-md); z-index:1000;">
                        <!-- Instruktionen werden dynamisch gesetzt -->
                    </div>
                </div>
            </div>
        </div>
    </div>


    <!-- Gewässer Modal (ALT - wird ggf. durch Universal-Karte abgelöst) -->
    <div class="modal" id="gewaesserModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="gewaesserModalTitle">Neues Gewässer anlegen</h2>
                <button class="close-btn" onclick="closeGewaesserModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="gewaesserForm">
                <div class="form-group">
                    <label class="form-label" for="gewaesserNameInput">Name</label>
                    <input type="text" class="form-control" id="gewaesserNameInput" required placeholder="z.B. Bleilochtalsperre">
                </div>
                <div class="form-group">
                    <label class="form-label" for="gewaesserType">Typ</label>
                    <select class="form-control" id="gewaesserType" required>
                        <option value="">Bitte wählen...</option>
                        <option value="river">Fluss</option>
                        <option value="lake">See</option>
                        <option value="reservoir">Talsperre</option>
                        <option value="pond">Teich</option>
                        <option value="canal">Kanal</option>
                        <option value="stream">Bach</option>
                        <option value="spot">Spot (spezifischer Angelplatz)</option>
                        <option value="other">Anderer Typ</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="gewaesserSize">Größe</label>
                    <input type="text" class="form-control" id="gewaesserSize" placeholder="z.B. 920 ha">
                </div>

                <div class="form-group">
                    <label class="form-label" for="gewaesserDepthSlider">Maximale Tiefe: <span id="gewaesserDepthValueDisplay">10</span> m</label>
                    <div class="slider-input-group">
                        <button type="button" class="btn btn-icon btn-sm" onclick="decrementGewaesserDepth()">-</button>
                        <input type="range" class="form-control" id="gewaesserDepthSlider" min="0" max="200" step="0.5" value="10"
                               oninput="updateGewaesserDepthDisplay(this.value);">
                        <button type="button" class="btn btn-icon btn-sm" onclick="incrementGewaesserDepth()">+</button>
                    </div>
                    <input type="hidden" id="gewaesserDepth" name="gewaesserDepth" value="10">
                </div>

                <div class="form-group">
                    <label class="form-label" for="gewaesserLocationInput">GPS Koordinaten (Lat, Lon)</label>
                     <div class="location-input-group">
                        <input type="text" class="form-control" id="gewaesserLocationInput" placeholder="z.B. 50.5876, 11.3547">
                         <button type="button" class="btn btn-map btn-sm"
                                onclick="openUniversalMapModal('createGewaesserViaMap', null, 'gewaesserLocationInput', null, false)"
                                title="Position auf Karte festlegen">
                            <i class="fas fa-map-marked-alt"></i>
                        </button>
                    </div>
                     <div id="gewaesserLocationMap" style="display:none;"></div> <!-- Versteckt, da Universal-Karte bevorzugt -->
                </div>
                <div class="form-group">
                    <label class="form-label">Vorkommende Fischarten</label>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.5rem;">
                        <label><input type="checkbox" name="fishTypes" value="pike"> Hecht</label>
                        <label><input type="checkbox" name="fishTypes" value="zander"> Zander</label>
                        <label><input type="checkbox" name="fishTypes" value="perch"> Barsch</label>
                        <label><input type="checkbox" name="fishTypes" value="eel"> Aal</label>
                        <label><input type="checkbox" name="fishTypes" value="carp"> Karpfen</label>
                        <label><input type="checkbox" name="fishTypes" value="trout"> Forelle</label>
                        <label><input type="checkbox" name="fishTypes" value="tench"> Schleie</label>
                        <label><input type="checkbox" name="fishTypes" value="other_species"> Andere</label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="gewaesserNotes">Besonderheiten</label>
                    <textarea class="form-control" id="gewaesserNotes" rows="4" placeholder="Strukturen, beste Angelplätze, Besonderheiten..."></textarea>
                </div>
                <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                    <button type="button" class="btn btn-icon" onclick="closeGewaesserModal()">Abbrechen</button>
                    <button type="submit" class="btn">
                        <i class="fas fa-save"></i> Speichern
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Day Details Modal -->
    <div class="modal" id="dayModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="dayModalTitle">Details</h2>
                <button class="close-btn" onclick="closeDayModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="dayModalContent">
                <!-- Dynamically populated -->
            </div>
        </div>
    </div>

    <!-- Trip Planning Modal -->
    <div class="modal" id="tripPlanningModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="tripPlanningModalTitle">Angel-Trip planen</h2>
                <button class="close-btn" onclick="closeTripPlanningModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="tripPlanningForm">
                <input type="hidden" id="tripId">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem;">
                    <div>
                        <div class="form-group">
                            <label class="form-label" for="tripDate">Datum</label>
                            <input type="date" class="form-control" id="tripDate" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="tripTime">Uhrzeit (optional)</label>
                            <input type="time" class="form-control" id="tripTime">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="tripTypeSelect">Angelart</label>
                            <div style="display:flex; gap:0.5rem;">
                                <select class="form-control" id="tripTypeSelect" style="flex-grow:1;" onchange="populateTripEquipmentList(this.value, getCurrentSelectedEquipment())">
                                </select>
                                <input type="text" class="form-control" id="newTripTypeInput" placeholder="Neue Art" style="flex-basis: 150px;">
                                <button type="button" class="btn btn-icon" onclick="addFishingTypeFromTripModal()" title="Angelart zum Katalog hinzufügen"><i class="fas fa-plus"></i></button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="tripGewaesser">Gewässer</label>
                            <div class="location-input-group">
                                <select class="form-control" id="tripGewaesser" required style="flex: 1;">
                                    <!-- Optionen werden dynamisch gefüllt -->
                                </select>
                                <button type="button" class="btn btn-map" id="tripGewaesserMapButton" title="Gewässer auf Karte auswählen/anlegen" onclick="openMapForTripGewaesser()">
                                    <i class="fas fa-map-marked-alt"></i>
                                </button>
                            </div>
                            <input type="hidden" id="tripGewaesserIdStore"> <!-- Zum Speichern der ID, falls benötigt -->
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="tripNotes">Notizen</label>
                            <textarea class="form-control" id="tripNotes" rows="3"></textarea>
                        </div>
                    </div>
                    <div>
                        <h3 style="margin-bottom: 0.5rem;">Teilnehmer</h3>
                        <div id="tripParticipantsContainer" style="margin-bottom: 1rem;">
                        </div>
                        <button type="button" class="btn btn-sm" onclick="addTripParticipantField()" style="margin-bottom: 1.5rem;">
                            <i class="fas fa-user-plus"></i> Teilnehmer
                        </button>

                        <h3 style="margin-bottom: 0.5rem;">Packliste</h3>
                        <div class="form-group">
                             <label class="form-label" for="equipmentFilterType" style="font-size:0.9em;">Filter:</label>
                             <select class="form-control form-control-sm" id="equipmentFilterType" onchange="populateTripEquipmentList(this.value, getCurrentSelectedEquipment())">
                                 <option value="All">Alle Items anzeigen</option>
                             </select>
                        </div>
                        <div id="tripEquipmentContainer" style="max-height: 280px; overflow-y: auto; border: 1px solid var(--bg-tertiary); padding: 1rem; border-radius: var(--radius-md); margin-bottom:1rem;">
                        </div>
                        <div class="form-group" style="background: var(--bg-tertiary); padding:1rem; border-radius:var(--radius-md);">
                            <label class="form-label" style="font-size:0.9em;">Neuen Gegenstand zum Katalog:</label>
                             <div style="display:flex; gap:0.5rem; align-items:center;">
                                <input type="text" class="form-control form-control-sm" id="newEquipmentItemNameInput" placeholder="Name d. Gegenstands">
                                <select class="form-control form-control-sm" id="newEquipmentItemCategorySelect" style="min-width:130px;">
                                </select>
                                <button type="button" class="btn btn-icon btn-sm" onclick="addEquipmentCatalogItemFromTripModal()" title="Gegenstand zum Katalog hinzufügen"><i class="fas fa-plus"></i></button>
                             </div>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 2rem;">
                    <button type="button" class="btn btn-icon" onclick="closeTripPlanningModal()">Abbrechen</button>
                    <button type="button" class="btn btn-warning" onclick="exportTripToPDF()">
                        <i class="fas fa-file-pdf"></i> PDF Speichern
                    </button>
                    <button type="submit" class="btn btn-success">
                        <i class="fas fa-save"></i> Trip speichern
                    </button>
                </div>
            </form>
        </div>
    </div>

     <!-- User Equipment Set Modal -->
    <div class="modal" id="userEquipmentSetModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="userEquipmentSetModalTitle">Ausrüstungs-Set erstellen/bearbeiten</h2>
                <button class="close-btn" onclick="closeUserEquipmentSetModal()">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="userEquipmentSetForm">
                <input type="hidden" id="editingUserEquipmentSetId">
                <div class="form-group">
                    <label class="form-label" for="userEquipmentSetName">Name des Sets</label>
                    <input type="text" class="form-control" id="userEquipmentSetName" placeholder="z.B. Spinnfischen Hecht leicht" required>
                </div>

                 <div class="form-group">
                    <label class="form-label">Zugehörige Angelarten</label>
                    <div id="userSetApplicableFishingTypesContainer" class="inline-checkbox-container">
                        <!-- Checkboxen für Angelarten werden hier von JS eingefügt -->
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Bestandteile des Sets</label>
                    <div id="userEquipmentSetItemsContainer">
                        <!-- Dynamisch gefüllt mit Selects für Katalog-Items -->
                    </div>
                    <button type="button" class="btn btn-sm" onclick="addUserEquipmentSetItemField()" style="margin-top:0.5rem;">
                        <i class="fas fa-plus"></i> Gegenstand hinzufügen
                    </button>
                </div>

                 <div class="form-group">
                    <label class="form-label" for="userEquipmentSetNotes">Notizen zum Set</label>
                    <textarea class="form-control" id="userEquipmentSetNotes" rows="3" placeholder="Verwendungszweck, spezielle Eigenschaften..."></textarea>
                </div>

                <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 2rem;">
                    <button type="button" class="btn btn-icon" onclick="closeUserEquipmentSetModal()">Abbrechen</button>
                    <button type="submit" class="btn btn-success">
                        <i class="fas fa-save"></i> Set speichern
                    </button>
                </div>
            </form>
        </div>
    </div>


    <!-- Theme Toggle -->
    <div class="theme-toggle no-print" onclick="toggleTheme()">
        <i class="fas fa-moon" id="themeIcon"></i>
    </div>

    <!-- JavaScript -->
    <script>

// Enhanced Fish Database
const fishDatabase = {
    pike: { name: 'Hecht', scientificName: 'Esox lucius', icon: '🦈', optimalTemp: { min: 8, max: 15 }, activeTemp: { min: 4, max: 20 }, optimalPressure: 'falling', pressureRange: { min: 1000, max: 1015 }, bestTimes: ['dawn', 'dusk'], bestMonths: [9, 10, 11, 3, 4, 5], moonPreference: 'full', weatherPreference: 'cloudy', windPreference: { min: 5, max: 15 }, cloudPreference: { min: 60, max: 90 }, behaviors: { spring: { activity: 0.8, depth: 'shallow', pattern: 'aggressive' }, summer: { activity: 0.5, depth: 'deep', pattern: 'ambush' }, autumn: { activity: 0.9, depth: 'medium', pattern: 'hunting' }, winter: { activity: 0.3, depth: 'deep', pattern: 'lethargic' } } },
    zander: { name: 'Zander', scientificName: 'Sander lucioperca', icon: '🐟', optimalTemp: { min: 12, max: 20 }, activeTemp: { min: 8, max: 24 }, optimalPressure: 'falling', pressureRange: { min: 1005, max: 1020 }, bestTimes: ['dusk', 'night'], bestMonths: [5, 6, 9, 10], moonPreference: 'new', weatherPreference: 'cloudy', windPreference: { min: 0, max: 10 }, cloudPreference: { min: 70, max: 100 }, behaviors: { spring: { activity: 0.7, depth: 'medium', pattern: 'cruising' }, summer: { activity: 0.6, depth: 'deep', pattern: 'nocturnal' }, autumn: { activity: 0.8, depth: 'deep', pattern: 'schooling' }, winter: { activity: 0.4, depth: 'very_deep', pattern: 'sluggish' } } },
    perch: { name: 'Barsch', scientificName: 'Perca fluviatilis', icon: '🐠', optimalTemp: { min: 15, max: 22 }, activeTemp: { min: 6, max: 25 }, optimalPressure: 'stable', pressureRange: { min: 1010, max: 1025 }, bestTimes: ['morning', 'afternoon', 'dusk'], bestMonths: [5, 6, 7, 8, 9], moonPreference: 'any', weatherPreference: 'varied', windPreference: { min: 5, max: 20 }, cloudPreference: { min: 30, max: 70 }, behaviors: { spring: { activity: 0.7, depth: 'shallow', pattern: 'schooling' }, summer: { activity: 0.8, depth: 'varied', pattern: 'active' }, autumn: { activity: 0.7, depth: 'medium', pattern: 'hunting' }, winter: { activity: 0.5, depth: 'deep', pattern: 'schooling' } } },
    eel: { name: 'Aal', scientificName: 'Anguilla anguilla', icon: '🐍', optimalTemp: { min: 18, max: 24 }, activeTemp: { min: 12, max: 26 }, optimalPressure: 'low', pressureRange: { min: 990, max: 1010 }, bestTimes: ['night', 'late_evening'], bestMonths: [6, 7, 8, 9], moonPreference: 'new', weatherPreference: 'thunderstorm', windPreference: { min: 10, max: 25 }, cloudPreference: { min: 80, max: 100 }, behaviors: { spring: { activity: 0.4, depth: 'bottom', pattern: 'migrating' }, summer: { activity: 0.9, depth: 'bottom', pattern: 'nocturnal_feeding' }, autumn: { activity: 0.7, depth: 'bottom', pattern: 'migrating_feeding' }, winter: { activity: 0.1, depth: 'deep_mud', pattern: 'hibernating' } } },
    carp: { name: 'Karpfen', scientificName: 'Cyprinus carpio', icon: '🐋', optimalTemp: { min: 20, max: 26 }, activeTemp: { min: 12, max: 30 }, optimalPressure: 'stable', pressureRange: { min: 1010, max: 1025 }, bestTimes: ['dawn', 'morning', 'dusk'], bestMonths: [5, 6, 7, 8, 9], moonPreference: 'full', weatherPreference: 'stable_warm', windPreference: { min: 0, max: 15 }, cloudPreference: { min: 40, max: 80 }, behaviors: { spring: { activity: 0.7, depth: 'shallow', pattern: 'feeding_spawning_prep' }, summer: { activity: 0.8, depth: 'varied', pattern: 'active_feeding' }, autumn: { activity: 0.9, depth: 'medium', pattern: 'pre_winter_feeding_binge' }, winter: { activity: 0.2, depth: 'deep_holes', pattern: 'dormant_occasional_feed' } } },
    trout: { name: 'Forelle', scientificName: 'Salmo trutta', icon: '🐟', optimalTemp: { min: 10, max: 16 }, activeTemp: { min: 4, max: 20 }, optimalPressure: 'rising', pressureRange: { min: 1015, max: 1030 }, bestTimes: ['dawn', 'morning', 'evening'], bestMonths: [4, 5, 6, 9, 10], moonPreference: 'quarter', weatherPreference: 'overcast_drizzle', windPreference: { min: 5, max: 15 }, cloudPreference: { min: 60, max: 90 }, behaviors: { spring: { activity: 0.8, depth: 'shallow_riffles', pattern: 'active_feeding_insects' }, summer: { activity: 0.5, depth: 'deep_pools_shade', pattern: 'oxygen_seeking_lethargic_hot' }, autumn: { activity: 0.7, depth: 'medium_gravel', pattern: 'spawning_aggressive' }, winter: { activity: 0.4, depth: 'deep_slow_water', pattern: 'slow_opportunistic' } } },
    tench: { name: 'Schleie', scientificName: 'Tinca tinca', icon: '🐠', optimalTemp: { min: 18, max: 24 }, activeTemp: { min: 12, max: 26 }, optimalPressure: 'stable', pressureRange: { min: 1008, max: 1022 }, bestTimes: ['dawn', 'dusk'], bestMonths: [5, 6, 7, 8], moonPreference: 'any', weatherPreference: 'warm_calm', windPreference: { min: 0, max: 10 }, cloudPreference: { min: 20, max: 60 }, behaviors: { spring: { activity: 0.6, depth: 'shallow_margins_weeds', pattern: 'spawning_feeding' }, summer: { activity: 0.8, depth: 'shallow_lilypads', pattern: 'feeding_bubbles' }, autumn: { activity: 0.5, depth: 'medium_silt', pattern: 'preparing_winter_less_active' }, winter: { activity: 0.1, depth: 'deep_mud', pattern: 'hibernating' } } }
};
const methodKeyMap = { "Spinnfischen": "spinnfischen", "Grundangeln": "grundangeln", "Posenfischen": "posenfischen", "Fliegenfischen": "fliegenfischen", "Feederangeln": "feederangeln", "Köderfischen": "koederfischen", "Ultraleicht Angeln": "ultraleicht", "Friedfisch": "friedfisch", "Raubfisch": "raubfisch", "Allgemein": "allgemein", "Andere Methode": "other_method" };


// Global Variables
let currentAngelgang = null;
let angelgangTimer = null;
let catches = [];
let angelgangs = [];
let gewaesser = [];
let userEquipmentSets = [];
let plannedTrips = [];
let fishingTypes = ["Spinnfischen", "Grundangeln", "Posenfischen", "Fliegenfischen", "Feederangeln", "Köderfischen", "Ultraleicht Angeln", "Friedfisch", "Raubfisch", "Allgemein", "Andere Methode"];
let equipmentCatalog = [
    { id: 'rute_spinn_std', name: "Spinnrute Standard", category: "Spinnfischen" }, { id: 'koederbox_hecht_std', name: "Köderbox Hecht", category: "Spinnfischen" }, { id: 'rute_grund_std', name: "Grundrute Standard", category: "Grundangeln" }, { id: 'futterkorb_std', name: "Futterkorb Set", category: "Feederangeln" }, { id: 'rute_fliege_std', name: "Fliegenrute #5/6", category: "Fliegenfischen" }, { id: 'fliegendose_std', name: "Fliegendose Nymphen", category: "Fliegenfischen" }, { id: 'kescher_std', name: "Unterfangkescher", category: "Allgemein" }, { id: 'messer_std', name: "Filetiermesser", category: "Allgemein" }, { id: 'stuhl_std', name: "Angelstuhl", category: "Allgemein" }, { id: 'schirm_std', name: "Angelschirm", category: "Allgemein" }, { id: 'zange_std', name: "Lösezange", category: "Allgemein" }, { id: 'grill_std', name: "Campinggrill", category: "Allgemein" }, { id: 'getraenke_std', name: "Getränke", category: "Allgemein" },
];
const defaultParticipantColors = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#1abc9c', '#e67e22', '#7f8c8d'];
let participantColorIndex = 0;

let currentMonth = new Date().getMonth();
let currentYear = new Date().getFullYear();
let currentPosition = null;
let map = null; // Hauptkarte im Gewässer-Tab
let gewaesserMarkers = []; // Marker für die Hauptkarte
let currentPositionMarker = null; // Marker für aktuelle Position auf Hauptkarte

let gewaesserModalMap = null; // Karte im alten Gewässer-Anlege-Modal (ggf. obsolet)
let newGewaesserMarker = null; // Für Gewässer-Anlege-Modal (ggf. obsolet)

// Universal Map (basiert auf catchLocationMapModal)
let catchLocationMap = null; // Die Leaflet-Instanz der Universal-Karte
let tempCatchLocationMarker = null; // Temporärer Marker für Nutzerinteraktion auf Universal-Karte
let catchMapGewaeserMarkers = []; // Array für Marker von bestehenden Gewässern auf der Universal-Karte
let selectedGewaesserForCatchMap = null; // Hält die ID des in der Liste ausgewählten Gewässers

// Kontext für Universal-Karte
let universalMapContext = null; // 'selectGewasserForAngelgang', 'selectCatchLocation', 'createGewaesserViaMap', 'manageGewaesserTab', 'editGewaesserPosition'
let universalMapTargetInputGewaesserId = null;
let universalMapTargetInputCoords = null;
let universalMapTargetDisplayCallback = null; // Name der Callback-Funktion zum Aktualisieren der Anzeige im aufrufenden Formular
let universalMapEditingGewaesserId = null; // ID des Gewässers, das gerade in der Karte bearbeitet wird


let weatherData = null;
let pressureHistory = [];
let isEditingCatch = false;
let openWeatherApiKey = '';

const baitOptionsByMethod = {
    spinnfischen: [ {value: "wobbler_klein", text: "Wobbler (klein, Barsch/Forelle)"}, {value: "wobbler_mittel", text: "Wobbler (mittel, Zander/Hecht)"}, {value: "wobbler_gross", text: "Wobbler (groß, Hecht/Wels)"}, {value: "gummifisch_klein", text: "Gummifisch (5-10cm)"}, {value: "gummifisch_mittel", text: "Gummifisch (10-15cm)"}, {value: "gummifisch_gross", text: "Gummifisch (>15cm)"}, {value: "spinner_klein", text: "Spinner (Gr. 0-2)"}, {value: "spinner_mittel", text: "Spinner (Gr. 3-4)"}, {value: "spinner_gross", text: "Spinner (Gr. 5+)"}, {value: "blinker", text: "Blinker"}, {value: "spoon_forelle", text: "Spoon (Forelle)"}, {value: "chatterbait", text: "Chatterbait"}, {value: "jigspinner", text: "Jigspinner / Spinjig"}, {value: "topwater", text: "Topwater-Köder (Popper, Stickbait)"}, {value: "durchlaufblinker", text: "Durchlaufblinker (Meerforelle)"} ],
    grundangeln: [ {value: "tauwurm", text: "Tauwurm"}, {value: "dendrobena", text: "Dendrobena / Rotwurm"}, {value: "boilie_fruchtig", text: "Boilie (fruchtig)"}, {value: "boilie_fischig", text: "Boilie (fischig)"}, {value: "boilie_spice", text: "Boilie (würzig)"}, {value: "pellet_klein", text: "Pellet (klein, Friedfisch)"}, {value: "pellet_gross", text: "Pellet (groß, Karpfen/Wels)"}, {value: "mais", text: "Mais / Hartmais"}, {value: "teig_fertig", text: "Fertigteig"}, {value: "teig_selbstgemacht", text: "Selbstgemachter Teig"}, {value: "kartoffel", text: "Kartoffel"}, {value: "koederfisch_tot", text: "Köderfisch (tot, auf Grund)"}, {value: "fischfetzen", text: "Fischfetzen"} ],
    posenfischen: [ {value: "made", text: "Made / Pinkie"}, {value: "caster", text: "Caster"}, {value: "mais_dose", text: "Dosenmais"}, {value: "rotwurm", text: "Rotwurm / Mistwurm"}, {value: "brotflocke", text: "Brotflocke"}, {value: "brotteig", text: "Brotteig"}, {value: "regenwurm_klein", text: "Regenwurm (klein)"}, {value: "koederfisch_klein_pose", text: "Köderfisch (klein, an Pose)"}, {value: "heuschrecke_grashuepfer", text: "Heuschrecke / Grashüpfer (Oberfläche)"} ],
    fliegenfischen: [ {value: "trockenfliege_eintags", text: "Trockenfliege (Eintagsfliege Imit.)"}, {value: "trockenfliege_kocher", text: "Trockenfliege (Köcherfliege Imit.)"}, {value: "trockenfliege_landinsekten", text: "Trockenfliege (Landinsekten Imit.)"}, {value: "nassfliege_standard", text: "Nassfliege (Standard)"}, {value: "nassfliege_emerger", text: "Nassfliege (Emerger)"}, {value: "nymphe_goldkopf", text: "Nymphe (Goldkopf)"}, {value: "nymphe_beschwert", text: "Nymphe (beschwert, Jig)"}, {value: "nymphe_unbeschwert", text: "Nymphe (unbeschwert)"}, {value: "streamer_klein", text: "Streamer (klein, Fischimitat)"}, {value: "streamer_gross", text: "Streamer (groß, Hechtstreamer)"}, {value: "popper_fliege", text: "Popper-Fliege"} ],
    feederangeln: [ {value: "maden_korb_haken", text: "Maden (Korb & Haken)"}, {value: "mais_korb_haken", text: "Mais (Korb & Haken)"}, {value: "pellets_mini_haken", text: "Mini-Pellets (Haken)"}, {value: "wurm_feeder", text: "Wurm (am Haar / Haken)"}, {value: "mini_boilie_feeder", text: "Mini-Boilie (Feeder)"}, {value: "caster_feeder", text: "Caster (Korb & Haken)"} ],
    koederfischen: [ {value: "koederfisch_system_spinn", text: "Köderfisch am System (Spinnfischen)"}, {value: "koederfisch_pose_raubfisch", text: "Köderfisch an Pose (Raubfisch)"}, {value: "koederfisch_grund_raubfisch", text: "Köderfisch auf Grund (Raubfisch)"}, {value: "fischfetzen_aktiv", text: "Fischfetzen (aktiv geführt)"} ],
    ultraleicht: [ {value: "ul_gummi_micro", text: "UL Gummifisch/Twister (<5cm)"}, {value: "ul_wobbler_mini", text: "UL Wobbler (Mini)"}, {value: "ul_spoon_micro", text: "UL Spoon (Micro, <3g)"}, {value: "ul_spinner_00_1", text: "UL Spinner (Gr. 00-1)"}, {value: "ul_jig_tungsten", text: "UL Jig (Tungsten, Micro)"}, {value: "ul_fliege_sbirulino", text: "Fliege am Sbirulino"} ],
    other_method: [ {value: "koeder_unbekannt", text: "Unbekannt / Nicht gelistet"} ]
};
baitOptionsByMethod[""] = [{value: "", text: "Erst Angelmethode wählen..."}]; // Für leere Auswahl

// Initialize Application
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

function updateConnectionStatus() {
    const statusEl = document.getElementById('connectionStatus');
    if (!statusEl) return;

    if (navigator.onLine) {
        statusEl.innerHTML = '<i class="fas fa-wifi"></i> Online';
        statusEl.className = 'connection-status online';
        statusEl.style.display = 'block'; // Make sure it's visible for the brief "online" message
        setTimeout(() => {
            // Only hide if it's still in the 'online' temporary display state
            if (statusEl.classList.contains('online')) {
                statusEl.style.display = 'none';
                statusEl.classList.remove('online'); // Reset class
            }
        }, 3000);
    } else {
        statusEl.innerHTML = '<i class="fas fa-wifi-slash"></i> Offline';
        statusEl.className = 'connection-status offline';
        statusEl.style.display = 'block'; // Ensure it's visible when offline
    }
}

function initializeApp() {
    loadApiKey();
    loadData();
    initializeMap(); // Hauptkarte für Gewässer-Tab
    getCurrentPosition(); // Holt Position und updated Wetter & Karten
    updateDashboard();
    populateGewaesserSelects();
    populateAllFishingTypeSelects();
    renderCalendar();
    setupEventListeners();
    updateApiKeyStatus();
    updateSettingsTabViews();
    updateUserEquipmentSetsDisplay();


    const rootStyle = getComputedStyle(document.documentElement);
    const bgPrimaryColor = rootStyle.getPropertyValue('--bg-primary').trim();
    document.documentElement.style.setProperty('--bg-primary-rgb', colorToRgb(bgPrimaryColor));


    setInterval(updateWeather, 30 * 60 * 1000);

    if (localStorage.getItem('theme') === 'dark') {
        document.body.setAttribute('data-theme', 'dark');
        document.getElementById('themeIcon').className = 'fas fa-sun';
        document.documentElement.style.setProperty('--bg-primary-rgb', colorToRgb(rootStyle.getPropertyValue('--bg-primary').trim())); // Re-evaluate for dark
    }
    // Initialisiere Slider-Anzeigen
    updateFishSizeDisplay(document.getElementById('fishSizeSlider').value);
    updateFishWeightDisplay(document.getElementById('fishWeightSlider').value);
    updatePlannedDurationDisplay(document.getElementById('plannedDurationSlider').value);
    updateGewaesserDepthDisplay(document.getElementById('gewaesserDepthSlider').value);

    // Connection status
    updateConnectionStatus(); // Initial check
    window.addEventListener('online', updateConnectionStatus);
    window.addEventListener('offline', updateConnectionStatus);
}
function colorToRgb(colorString) {
    if (!colorString) return '255,255,255'; // Fallback
    let s = document.createElement('div');
    s.style.color = colorString;
    document.body.appendChild(s);
    let computedColor = window.getComputedStyle(s).color;
    document.body.removeChild(s);
    const match = computedColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
    if (match) {
        return `${match[1]},${match[2]},${match[3]}`;
    }
    return '255,255,255'; // Default if parsing fails
}


// API Key Management
function loadApiKey() { openWeatherApiKey = localStorage.getItem('openWeatherApiKey') || ''; }
function saveApiKey() { openWeatherApiKey = document.getElementById('apiKeyInput').value.trim(); localStorage.setItem('openWeatherApiKey', openWeatherApiKey); alert('API Key gespeichert!'); updateApiKeyStatus(); updateWeather(); }
function updateApiKeyStatus() {
    const statusEl = document.getElementById('apiKeyStatus'); const inputEl = document.getElementById('apiKeyInput');
    if (openWeatherApiKey) { statusEl.textContent = 'API Key ist gespeichert.'; inputEl.value = openWeatherApiKey; statusEl.style.color = 'var(--success-gradient)'; /* Textfarbe direkt setzen statt Gradient */ const successColor = getComputedStyle(document.documentElement).getPropertyValue('--success-gradient').split(',')[1] || '#11998e'; statusEl.style.color = successColor; }
    else { statusEl.textContent = 'Kein API Key gespeichert. Wetterdaten sind nicht verfügbar.'; const dangerColor = getComputedStyle(document.documentElement).getPropertyValue('--danger-gradient').split(',')[1] || '#f85032'; statusEl.style.color = dangerColor; }
}


// Data Management
function loadData() {
    catches = JSON.parse(localStorage.getItem('catches') || '[]');
    angelgangs = JSON.parse(localStorage.getItem('angelgangs') || '[]');
    gewaesser = JSON.parse(localStorage.getItem('gewaesser') || '[]');
    userEquipmentSets = JSON.parse(localStorage.getItem('userEquipmentSets') || '[]');
    currentAngelgang = JSON.parse(localStorage.getItem('currentAngelgang') || 'null');
    pressureHistory = JSON.parse(localStorage.getItem('pressureHistory') || '[]');
    plannedTrips = JSON.parse(localStorage.getItem('plannedTrips') || '[]');
    const defaultFishingTypes = ["Spinnfischen", "Grundangeln", "Posenfischen", "Fliegenfischen", "Feederangeln", "Köderfischen", "Ultraleicht Angeln", "Friedfisch", "Raubfisch", "Allgemein", "Andere Methode"];
    fishingTypes = JSON.parse(localStorage.getItem('fishingTypes') || JSON.stringify(defaultFishingTypes));
    defaultFishingTypes.forEach(dft => { if (!fishingTypes.includes(dft)) fishingTypes.push(dft);});


    const defaultEquipment = [ { id: 'rute_spinn_std', name: "Spinnrute Standard", category: "Spinnfischen" }, { id: 'koederbox_hecht_std', name: "Köderbox Hecht", category: "Spinnfischen" }, { id: 'rute_grund_std', name: "Grundrute Standard", category: "Grundangeln" }, { id: 'futterkorb_std', name: "Futterkorb Set", category: "Feederangeln" }, { id: 'rute_fliege_std', name: "Fliegenrute #5/6", category: "Fliegenfischen" }, { id: 'fliegendose_std', name: "Fliegendose Nymphen", category: "Fliegenfischen" }, { id: 'kescher_std', name: "Unterfangkescher", category: "Allgemein" }, { id: 'messer_std', name: "Filetiermesser", category: "Allgemein" }, { id: 'stuhl_std', name: "Angelstuhl", category: "Allgemein" }, { id: 'schirm_std', name: "Angelschirm", category: "Allgemein" }, { id: 'zange_std', name: "Lösezange", category: "Allgemein" }, { id: 'grill_std', name: "Campinggrill", category: "Allgemein" }, { id: 'getraenke_std', name: "Getränke", category: "Allgemein" }];
    equipmentCatalog = JSON.parse(localStorage.getItem('equipmentCatalog') || JSON.stringify(defaultEquipment));

    if (currentAngelgang && currentAngelgang.startTime && !currentAngelgang.paused) {
        startAngelgangTimer();
    } else if (currentAngelgang && currentAngelgang.paused) {
        startAngelgangTimer(); // Update display even if paused
    }
}
function saveData() {
    localStorage.setItem('catches', JSON.stringify(catches));
    localStorage.setItem('angelgangs', JSON.stringify(angelgangs));
    localStorage.setItem('gewaesser', JSON.stringify(gewaesser));
    localStorage.setItem('userEquipmentSets', JSON.stringify(userEquipmentSets));
    localStorage.setItem('currentAngelgang', JSON.stringify(currentAngelgang));
    localStorage.setItem('pressureHistory', JSON.stringify(pressureHistory));
    localStorage.setItem('plannedTrips', JSON.stringify(plannedTrips));
    localStorage.setItem('fishingTypes', JSON.stringify(fishingTypes));
    localStorage.setItem('equipmentCatalog', JSON.stringify(equipmentCatalog));
}

// Event Listeners Setup
function setupEventListeners() {
    document.getElementById('angelgangForm').addEventListener('submit', handleAngelgangSubmit);
    document.getElementById('catchForm').addEventListener('submit', handleCatchSubmit);
    document.getElementById('gewaesserForm').addEventListener('submit', handleGewaesserSubmit);
    document.getElementById('tripPlanningForm').addEventListener('submit', handleTripPlanningSubmit);
    document.getElementById('userEquipmentSetForm').addEventListener('submit', handleUserEquipmentSetSubmit);

    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', function(e) {
            if (e.target === this) { // Click on backdrop
                this.classList.remove('active');
                if (this.id === 'catchModal' && isEditingCatch) resetCatchFormForNewEntry();
                if (this.id === 'gewaesserModal') destroyGewaesserModalMap();
                if (this.id === 'tripPlanningModal') closeTripPlanningModal();
                if (this.id === 'userEquipmentSetModal') closeUserEquipmentSetModal();
                if (this.id === 'catchLocationMapModal') closeCatchLocationMapModal();
            }
        });
    });
    // Setzt die aktuelle Zeit für das Fang-Modal standardmäßig, wenn es nicht zum Bearbeiten geöffnet wird
    if (!document.getElementById('editingCatchIdStore').value) {
        const now = new Date();
        now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const localDateTimeString = `${year}-${month}-${day}T${hours}:${minutes}`;
        document.getElementById('catchDate').value = localDateTimeString;
    }
}

// Tab Navigation
function switchTab(tabName, event) { // event hinzugefügt
    document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
    document.getElementById(`${tabName}-tab`).classList.add('active');
    if (event && event.currentTarget) { // Sicherstellen, dass event und currentTarget existieren
         event.currentTarget.classList.add('active');
    }


    if (tabName === 'angelgang') updateAngelgangContent();
    else if (tabName === 'statistics') updateStatistics();
    else if (tabName === 'gewaesser') {
        updateGewaesserList();
        if (map) map.invalidateSize();
    }
    else if (tabName === 'settings') { updateApiKeyStatus(); updateSettingsTabViews(); updateUserEquipmentSetsDisplay(); }
    else if (tabName === 'calendar') renderCalendar();
}

// Weather Functions
async function updateWeather() { if (!currentPosition) { console.log("Current position not available for weather update."); } if (!openWeatherApiKey) { document.getElementById('temperature').textContent = "Key fehlt"; document.getElementById('pressure').textContent = "Key fehlt"; document.getElementById('wind').textContent = "Key fehlt"; updateProbabilities(); updateSolunarTimes(); updateMoonPhase(); return; } const lat = currentPosition ? currentPosition.lat : 50.643464; const lon = currentPosition ? currentPosition.lon : 11.918244; try { const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${openWeatherApiKey}&units=metric&lang=de`); if (!response.ok) { const errorData = await response.json(); if (response.status === 401) { console.error('Weather API Error: Ungültiger API Key.'); alert('Fehler Wetterabfrage: API Key ungültig.'); document.getElementById('temperature').textContent = "Key Problem"; document.getElementById('pressure').textContent = "Key Problem"; document.getElementById('wind').textContent = "Key Problem"; } else { throw new Error(`Weather API Error: ${response.status} - ${errorData.message || 'Unbekannt'}`); } weatherData = null; } else { weatherData = await response.json(); } if (weatherData) { document.getElementById('temperature').textContent = `${Math.round(weatherData.main.temp)}°C`; document.getElementById('pressure').textContent = `${weatherData.main.pressure} hPa`; document.getElementById('wind').textContent = `${Math.round(weatherData.wind.speed * 3.6)} km/h`; updatePressureTrend(weatherData.main.pressure); } updateMoonPhase(); updateProbabilities(); updateSolunarTimes(); } catch (error) { console.error('Weather update failed:', error); document.getElementById('temperature').textContent = "Fehler"; document.getElementById('pressure').textContent = "Fehler"; document.getElementById('wind').textContent = "Fehler"; weatherData = null; updateProbabilities(); } }
function updatePressureTrend(currentPressure) { pressureHistory.push({ pressure: currentPressure, timestamp: new Date().getTime() }); const dayAgo = new Date().getTime() - 24 * 60 * 60 * 1000; pressureHistory = pressureHistory.filter(p => p.timestamp > dayAgo); const trendElement = document.getElementById('pressureTrend'); if (pressureHistory.length >= 3) { const recent = pressureHistory.slice(-3); const trendValue = recent[2].pressure - recent[0].pressure; if (trendValue > 0.5) { trendElement.innerHTML = '<i class="fas fa-arrow-up"></i>'; trendElement.className = 'pressure-trend rising'; } else if (trendValue < -0.5) { trendElement.innerHTML = '<i class="fas fa-arrow-down"></i>'; trendElement.className = 'pressure-trend falling'; } else { trendElement.innerHTML = '<i class="fas fa-minus"></i>'; trendElement.className = 'pressure-trend stable'; } } else { trendElement.innerHTML = '<i class="fas fa-minus"></i>'; trendElement.className = 'pressure-trend stable'; } saveData(); }
function updateMoonPhase() { const moonData = getMoonPhase(new Date()); document.getElementById('moonPhase').textContent = moonData.name; const moonVisual = document.getElementById('moonPhaseVisual'); if (moonVisual) { moonVisual.innerHTML = ''; const phaseDiv = document.createElement('div'); phaseDiv.style.width = '100%'; phaseDiv.style.height = '100%'; phaseDiv.style.borderRadius = '50%'; phaseDiv.style.position = 'absolute'; const lightPart = document.createElement('div'); lightPart.style.width = '100%'; lightPart.style.height = '100%'; lightPart.style.borderRadius = '50%'; lightPart.style.background = '#f0f0f0'; moonVisual.appendChild(lightPart); const darkPart = document.createElement('div'); darkPart.style.width = '100%'; darkPart.style.height = '100%'; darkPart.style.borderRadius = '50%'; darkPart.style.background = '#333333'; darkPart.style.position = 'absolute'; darkPart.style.top = '0'; darkPart.style.left = '0'; darkPart.style.clipPath = moonData.clipPath; moonVisual.appendChild(darkPart); } }
function getMoonPhase(date) { let Y = date.getFullYear(), M = date.getMonth() + 1, D = date.getDate(), c = 0, e = 0, jd = 0, b = 0; if (M < 3) { Y--; M += 12; } let A = Math.floor(Y / 100); let B = Math.floor(A / 4); c = 2 - A + B; e = Math.floor(365.25 * (Y + 4716)); let f = Math.floor(30.6001 * (M + 1)); jd = c + D + e + f - 1524.5; let daysSinceNew = jd - 2451549.5; let newMoons = daysSinceNew / 29.53058861; b = Math.floor(newMoons); let age = (newMoons - b) * 29.53; let phaseValue = age / 29.53; let illumination = 0.5 * (1 - Math.cos(2 * Math.PI * phaseValue)); let name = "", clipPath = ""; if (age < 1.8456) { name = 'Neumond'; illumination = 0; } else if (age < 5.5368) name = 'Zunehmende Sichel'; else if (age < 9.2280) { name = 'Erstes Viertel'; illumination = 0.5; } else if (age < 12.9192) name = 'Zunehmender Mond'; else if (age < 16.6104) { name = 'Vollmond'; illumination = 1;} else if (age < 20.3016) name = 'Abnehmender Mond'; else if (age < 23.9928) { name = 'Letztes Viertel'; illumination = 0.5; } else if (age < 27.6840) name = 'Abnehmende Sichel'; else { name = 'Neumond'; illumination = 0; } if (name === 'Neumond') clipPath = 'circle(100% at 50% 50%)'; else if (name === 'Vollmond') clipPath = 'circle(0% at 50% 50%)'; else if (name === 'Erstes Viertel') clipPath = 'polygon(50% 0%, 100% 0%, 100% 100%, 50% 100%)'; else if (name === 'Letztes Viertel') clipPath = 'polygon(0% 0%, 50% 0%, 50% 100%, 0% 100%)'; else if (name === 'Zunehmende Sichel' || name === 'Zunehmender Mond') { let percent = Math.round(illumination * 100); clipPath = `inset(0 0 0 ${100 - percent}%)`; } else if (name === 'Abnehmende Sichel' || name === 'Abnehmender Mond') { let percent = Math.round(illumination * 100); clipPath = `inset(0 ${percent}% 0 0)`; } return { phase: phaseValue, name, illumination, clipPath }; }
function updateSolunarTimes() { const now = new Date(); const lat = currentPosition ? currentPosition.lat : 50.643464; const lon = currentPosition ? currentPosition.lon : 11.918244; const solunarData = calculateSolunarTimes(now, lat, lon); const solunarContainer = document.getElementById('solunarTimes'); solunarContainer.innerHTML = ''; solunarData.forEach(period => { const periodDiv = document.createElement('div'); periodDiv.className = `solunar-period ${period.type}`; periodDiv.innerHTML = `<span class="solunar-label">${period.label}</span><span class="solunar-time">${period.time}</span>`; solunarContainer.appendChild(periodDiv); }); }
function calculateSolunarTimes(date, lat, lon) { const times = []; const baseHour = date.getHours(); const baseMinute = date.getMinutes(); const format = (h, m) => new Date(date.getFullYear(), date.getMonth(), date.getDate(), h, m).toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }); let offset1 = (Math.abs(Math.sin(date.getDate() + lat)) * 60) % 60; let offset2 = (Math.abs(Math.cos(date.getDate() + lon)) * 60) % 60; times.push({ type: 'major', label: 'Hauptzeit 1', time: format((baseHour + 2) % 24, (baseMinute + offset1) % 60) }); times.push({ type: 'major', label: 'Hauptzeit 2', time: format((baseHour + 14) % 24, (baseMinute + offset2) % 60) }); times.push({ type: 'minor', label: 'Nebenzeit 1', time: format((baseHour + 8) % 24, (baseMinute + offset2) % 60) }); times.push({ type: 'minor', label: 'Nebenzeit 2', time: format((baseHour + 20) % 24, (baseMinute + offset1) % 60) }); return times.sort((a, b) => a.time.localeCompare(b.time)); }
function updateProbabilities() { const container = document.getElementById('probabilityGrid'); container.innerHTML = ''; const probabilities = calculateBiteProbabilities(); probabilities.forEach(prob => { const probDiv = document.createElement('div'); probDiv.className = `fish-probability probability-${prob.level}`; probDiv.innerHTML = `<div class="fish-info"><div class="fish-icon">${prob.fish.icon}</div><div><div class="fish-name">${prob.fish.name}</div><div class="fish-score">${Math.round(prob.score)}%</div></div></div><div class="probability-bar"><div class="probability-fill" style="width: ${prob.score}%"></div></div>`; probDiv.onclick = () => showProbabilityDetails(prob); container.appendChild(probDiv); }); }
function calculateBiteProbabilities() { const now = new Date(); const currentMonthNum = now.getMonth() + 1; const currentHour = now.getHours(); const currentSeason = getSeason(); const currentMoonPhase = getMoonPhase(now); const probabilities = []; for (const [key, fish] of Object.entries(fishDatabase)) { let score = 50; const factors = {}; if (weatherData && weatherData.main) { const temp = weatherData.main.temp; if (temp >= fish.optimalTemp.min && temp <= fish.optimalTemp.max) { score += 15; factors.temperature = { value: 15, reason: 'Optimale Temperatur' }; } else if (temp >= fish.activeTemp.min && temp <= fish.activeTemp.max) { score += 7; factors.temperature = { value: 7, reason: 'Akzeptable Temperatur' }; } else { score -= 15; factors.temperature = { value: -15, reason: 'Ungünstige Temperatur' }; } const pressure = weatherData.main.pressure; const pressureTrend = getPressureTrend(); if (fish.optimalPressure === pressureTrend) { score += 10; factors.pressureTrend = { value: 10, reason: `Optimal (${pressureTrend})` }; } if (pressure >= fish.pressureRange.min && pressure <= fish.pressureRange.max) { score += 5; factors.pressureRange = { value: 5, reason: 'Günstiger Luftdruck' }; } else { score -=5; factors.pressureRange = { value: -5, reason: 'Ungünstiger Luftdruck'}; } if (weatherData.wind) { const windSpeed = weatherData.wind.speed * 3.6; if (windSpeed >= fish.windPreference.min && windSpeed <= fish.windPreference.max) { score += 5; factors.wind = { value: 5, reason: 'Optimale Windverhältnisse' }; } } if (weatherData.clouds) { const cloudCover = weatherData.clouds.all; if (cloudCover >= fish.cloudPreference.min && cloudCover <= fish.cloudPreference.max) { score += 5; factors.clouds = { value: 5, reason: 'Günstige Bewölkung' }; } } } else { factors.weather = { value: 0, reason: openWeatherApiKey ? 'Wetterdaten (noch) nicht verfügbar' : 'Wetterdaten (API Key fehlt)' }; } const timeOfDay = getTimeOfDay(currentHour); if (fish.bestTimes.includes(timeOfDay)) { score += 10; factors.time = { value: 10, reason: `Beste Beißzeit (${getTimeOfDayName(timeOfDay)})` }; } if (fish.bestMonths.includes(currentMonthNum)) { score += 10; factors.month = { value: 10, reason: 'Hauptsaison (Monat)' }; } if (fish.moonPreference === 'any' || (fish.moonPreference === 'full' && currentMoonPhase.illumination > 0.9) || (fish.moonPreference === 'new' && currentMoonPhase.illumination < 0.1) || (fish.moonPreference === 'quarter' && currentMoonPhase.illumination >= 0.4 && currentMoonPhase.illumination <= 0.6)) { score += 7; factors.moon = { value: 7, reason: `Günstige Mondphase (${currentMoonPhase.name})` }; } const behavior = fish.behaviors[currentSeason]; if (behavior) { score += (behavior.activity - 0.5) * 15; factors.seasonActivity = { value: Math.round((behavior.activity - 0.5) * 15), reason: `${capitalizeFirstLetter(currentSeason)} Aktivität` }; } score = Math.max(0, Math.min(100, Math.round(score))); let level; if (score >= 70) level = 'high'; else if (score >= 40) level = 'medium'; else level = 'low'; probabilities.push({ key, fish, score, level, factors }); } return probabilities.sort((a, b) => b.score - a.score); }
function getTimeOfDay(hour) { if (hour >= 5 && hour < 9) return 'dawn'; if (hour >= 9 && hour < 12) return 'morning'; if (hour >= 12 && hour < 17) return 'afternoon'; if (hour >= 17 && hour < 21) return 'dusk'; if (hour >= 21 || hour < 2) return 'night'; if (hour >= 2 && hour < 5) return 'late_night'; return 'night'; }
function getSeason() { const month = new Date().getMonth(); if (month >= 2 && month <= 4) return 'spring'; if (month >= 5 && month <= 7) return 'summer'; if (month >= 8 && month <= 10) return 'autumn'; return 'winter'; }
function getPressureTrend() { if (pressureHistory.length < 3) return 'stable'; const recent = pressureHistory.slice(-3); const trend = recent[2].pressure - recent[0].pressure; if (trend > 0.5) return 'rising'; if (trend < -0.5) return 'falling'; return 'stable'; }
function showProbabilityDetails(prob) { const modal = document.getElementById('dayModal'); const title = document.getElementById('dayModalTitle'); const content = document.getElementById('dayModalContent'); title.textContent = `${prob.fish.name} - Bissanalyse`; let factorHtml = '<div class="factor-breakdown">'; for (const [key, factor] of Object.entries(prob.factors)) { const scoreClass = factor.value > 0 ? 'positive' : (factor.value < 0 ? 'negative' : 'neutral'); let displayValue = factor.value; if (typeof factor.value === 'number' && factor.value !== 0) { displayValue = `${factor.value > 0 ? '+' : ''}${factor.value}`; } else if (factor.value === 0 && (key === 'weather' || key === 'pressureTrend' || key === 'pressureRange' || key === 'wind' || key === 'clouds')) { displayValue = ''; } factorHtml += `<div class="factor-item"><span>${factor.reason}</span><span class="factor-score ${scoreClass}">${displayValue}</span></div>`; } factorHtml += `<div class="factor-item" style="margin-top: 1rem; font-weight: bold; border-top: 2px solid var(--bg-primary);"><span>Gesamtwahrscheinlichkeit</span><span class="factor-score">${Math.round(prob.score)}%</span></div></div>`; const currentSeason = getSeason(); const seasonBehavior = prob.fish.behaviors[currentSeason]; content.innerHTML = `<div style="text-align: center; margin-bottom: 2rem;"><div style="font-size: 4rem;">${prob.fish.icon}</div><h3>${prob.fish.name}</h3><p style="font-style: italic; color: var(--text-secondary);">${prob.fish.scientificName}</p></div>${factorHtml}${seasonBehavior ? `<div style="margin-top: 2rem;"><h4>Empfohlene Taktik (${capitalizeFirstLetter(currentSeason)}):</h4><p>Tiefe: ${seasonBehavior.depth}</p><p>Verhalten: ${seasonBehavior.pattern}</p></div>` : ''}`; modal.classList.add('active'); }

// Angelgang Functions
function startAngelgangWizard() {
    document.getElementById('angelgangModal').classList.add('active');
    updateSelectedAngelgangGewaesserInfo(
        document.getElementById('selectedGewaesserHidden').value,
        document.getElementById('angelgangGewaesserCoordsStore').value
    );
    updatePlannedDurationDisplay(document.getElementById('plannedDurationSlider').value);
    populateAngelgangEquipmentSetSelect(document.getElementById('fishingMethod').value); // Initial population if method already selected
}
function closeAngelgangModal() { document.getElementById('angelgangModal').classList.remove('active'); document.getElementById('angelgangForm').reset(); }
function handleAngelgangSubmit(e) {
    e.preventDefault();
    const gewaesserId = document.getElementById('selectedGewaesserHidden').value;
    if (!gewaesserId && !document.getElementById('angelgangGewaesserCoordsStore').value) { // Erlaube auch nur Koordinaten, wenn z.B. ein Spot on-the-fly ohne Anlage als Gewässer genutzt wird
        alert("Bitte wählen Sie ein Gewässer über die Karte aus oder markieren Sie einen Angelplatz.");
        return;
    }
    const fishingMethodValue = document.getElementById('fishingMethod').value;
    if (!fishingMethodValue) {
        alert("Bitte wählen Sie eine Angelmethode aus.");
        return;
    }

    const angelgang = {
        id: Date.now(),
        startTime: new Date().toISOString(),
        targetFish: document.getElementById('targetFish').value,
        gewaesser: gewaesserId || null, // Kann null sein, wenn nur Coords
        gewaesserCoords: document.getElementById('angelgangGewaesserCoordsStore').value || null,
        method: fishingMethodValue,
        equipment: document.getElementById('equipment').value,
        plannedDuration: parseInt(document.getElementById('plannedDuration').value),
        catches: [],
        paused: false,
        totalPausedTime: 0,
        weather: weatherData && weatherData.main ? { temp: weatherData.main.temp, pressure: weatherData.main.pressure, wind: weatherData.wind.speed, clouds: weatherData.clouds?.all } : null
    };
    currentAngelgang = angelgang;
    saveData();
    closeAngelgangModal();
    startAngelgangTimer();
    updateDashboard();
    switchTab('angelgang', e); // e (event) weitergeben
}
function startAngelgangTimer() { if (angelgangTimer) clearInterval(angelgangTimer); angelgangTimer = setInterval(updateAngelgangDisplay, 1000); updateAngelgangDisplay(); }
function updateAngelgangDisplay() {
    const dashboardStatusDiv = document.getElementById('angelgangStatusDisplay');
    const angelgangContentDiv = document.getElementById('angelgangContent');

    if (!currentAngelgang) {
        const noAngelgangHtml = `<p>Kein aktiver Angelgang</p><button class="btn btn-success btn-large" onclick="startAngelgangWizard()"><i class="fas fa-play"></i> Neuen Angelgang starten</button>`;
        if (dashboardStatusDiv) dashboardStatusDiv.innerHTML = noAngelgangHtml;
        if (angelgangContentDiv && document.getElementById('angelgang-tab').classList.contains('active')) {
            angelgangContentDiv.innerHTML = `<div style="text-align: center; padding: 3rem;"><i class="fas fa-water" style="font-size: 4rem; color: var(--text-secondary); margin-bottom: 1rem; display: block;"></i>${noAngelgangHtml}</div>`;
        }
        return;
    }
    const startTime = new Date(currentAngelgang.startTime); const now = new Date(); let activelyRunMs = now.getTime() - startTime.getTime(); if (currentAngelgang.totalPausedTime) { activelyRunMs -= currentAngelgang.totalPausedTime; } if (currentAngelgang.paused && currentAngelgang.pauseStartTime) { activelyRunMs -= (now.getTime() - currentAngelgang.pauseStartTime); } activelyRunMs = Math.max(0, activelyRunMs); const plannedDurationMs = currentAngelgang.plannedDuration * 60 * 60 * 1000; let remainingTimeMs = plannedDurationMs - activelyRunMs; let timerLabel = ""; if (remainingTimeMs <= 0) { remainingTimeMs = 0; timerLabel = currentAngelgang.paused ? '(Pausiert)' : ' (Zeit abgelaufen!)'; } else { timerLabel = currentAngelgang.paused ? '(Pausiert)' : ''; } const hours = Math.floor(remainingTimeMs / 3600000); const minutes = Math.floor((remainingTimeMs % 3600000) / 60000); const seconds = Math.floor((remainingTimeMs % 60000) / 1000); const timerCountdownString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`; const commonInfoHtml = `<div class="angelgang-timer">${timerCountdownString} ${timerLabel}</div><div class="angelgang-info"><div class="angelgang-info-item"><strong>Zielfisch:</strong> ${fishDatabase[currentAngelgang.targetFish]?.name || currentAngelgang.targetFish}</div><div class="angelgang-info-item"><strong>Gewässer:</strong> ${getGewaesserName(currentAngelgang.gewaesser) || 'Direkter Spot'} ${currentAngelgang.gewaesserCoords ? `(${currentAngelgang.gewaesserCoords})` : ''}</div><div class="angelgang-info-item"><strong>Methode:</strong> ${getMethodName(currentAngelgang.method)}</div><div class="angelgang-info-item"><strong>Fänge:</strong> ${currentAngelgang.catches.length}</div></div>`; const actionButtonsHtml = `<div style="margin-top: 2rem; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">${currentAngelgang.paused ? `<button class="btn btn-success" onclick="resumeAngelgang()"><i class="fas fa-play"></i> Fortsetzen</button>` : `<button class="btn btn-warning" onclick="pauseAngelgang()"><i class="fas fa-pause"></i> Pause</button>`}<button class="btn btn-danger" onclick="endAngelgang()"><i class="fas fa-stop"></i> Beenden</button><button class="btn" onclick="openCatchModal()"><i class="fas fa-plus"></i> Fang</button></div>`; if (dashboardStatusDiv) { dashboardStatusDiv.innerHTML = commonInfoHtml + actionButtonsHtml; } if (angelgangContentDiv && document.getElementById('angelgang-tab').classList.contains('active')) { angelgangContentDiv.innerHTML = `<div id="activeAngelgangDisplay" class="angelgang-status">${commonInfoHtml}<div class="angelgang-info"><div class="angelgang-info-item"><strong>Ausrüstung:</strong> ${currentAngelgang.equipment || 'N/A'}</div><div class="angelgang-info-item"><strong>Geplant:</strong> ${currentAngelgang.plannedDuration} Std.</div></div>${actionButtonsHtml}</div>`; }
}
function pauseAngelgang() { if (currentAngelgang && !currentAngelgang.paused) { currentAngelgang.paused = true; currentAngelgang.pauseStartTime = new Date().getTime(); saveData(); updateAngelgangDisplay(); } }
function resumeAngelgang() { if (currentAngelgang && currentAngelgang.paused) { const pauseDuration = new Date().getTime() - currentAngelgang.pauseStartTime; currentAngelgang.totalPausedTime = (currentAngelgang.totalPausedTime || 0) + pauseDuration; currentAngelgang.paused = false; delete currentAngelgang.pauseStartTime; saveData(); updateAngelgangDisplay(); } }
function endAngelgang() { if (!currentAngelgang) return; if (confirm('Angelgang wirklich beenden?')) { currentAngelgang.endTime = new Date().toISOString(); if (currentAngelgang.paused && currentAngelgang.pauseStartTime) { const pauseDuration = new Date().getTime() - currentAngelgang.pauseStartTime; currentAngelgang.totalPausedTime = (currentAngelgang.totalPausedTime || 0) + pauseDuration; } angelgangs.push({...currentAngelgang}); const endedAngelgangName = getGewaesserName(currentAngelgang.gewaesser) || `Spot bei ${currentAngelgang.gewaesserCoords}`; const endedCatches = currentAngelgang.catches.length; currentAngelgang = null; if (angelgangTimer) clearInterval(angelgangTimer); angelgangTimer = null; saveData(); updateDashboard(); updateAngelgangContent(); updateAngelgangHistory(); renderCalendar(); alert(`Angelgang am ${endedAngelgangName} wurde beendet und mit ${endedCatches} Fängen gespeichert!`); } }
function updateAngelgangContent() { const content = document.getElementById('angelgangContent'); if (currentAngelgang) { updateAngelgangDisplay(); } else { content.innerHTML = `<div style="text-align: center; padding: 3rem;"><i class="fas fa-water" style="font-size: 4rem; color: var(--text-secondary); margin-bottom: 1rem; display: block;"></i><p style="font-size: 1.2rem; margin-bottom: 2rem;">Kein aktiver Angelgang</p><button class="btn btn-success btn-large" onclick="startAngelgangWizard()"><i class="fas fa-play"></i> Neuen Angelgang starten</button></div>`; updateDashboard(); } updateAngelgangHistory(); }
function updateAngelgangHistory() { const historyDiv = document.getElementById('angelgangHistory'); if (!historyDiv) return; if (angelgangs.length === 0) { historyDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Noch keine Angelgänge vorhanden</p>'; return; } const sortedAngelgangs = [...angelgangs].sort((a, b) => new Date(b.startTime) - new Date(a.startTime)); historyDiv.innerHTML = sortedAngelgangs.map(ag => { let durationMs = new Date(ag.endTime) - new Date(ag.startTime); if (ag.totalPausedTime) durationMs -= ag.totalPausedTime; durationMs = Math.max(0, durationMs); const hours = Math.floor(durationMs / 3600000); const minutes = Math.floor((durationMs % 3600000) / 60000); const displayName = getGewaesserName(ag.gewaesser) || `Spot ${ag.gewaesserCoords ? `(${ag.gewaesserCoords})` : '(Keine Koordinaten)'}`; return `<div class="catch-item" onclick="showAngelgangDetails('${ag.id}')"><div class="catch-details"><div class="catch-species">${displayName}</div><div class="catch-info">${new Date(ag.startTime).toLocaleDateString('de-DE')} | ${hours}h ${minutes}min | ${ag.catches.length} Fänge | Zielfisch: ${fishDatabase[ag.targetFish]?.name || ag.targetFish}</div></div></div>`; }).join(''); }
function showAngelgangDetails(angelgangId) { const ag = angelgangs.find(a => a.id == angelgangId); if (!ag) return; const modal = document.getElementById('dayModal'), title = document.getElementById('dayModalTitle'), content = document.getElementById('dayModalContent'); const displayName = getGewaesserName(ag.gewaesser) || `Spot ${ag.gewaesserCoords ? `(${ag.gewaesserCoords})` : '(Keine Koordinaten)'}`; title.textContent = `Angelgang Details: ${displayName}`; let durationMs = new Date(ag.endTime) - new Date(ag.startTime); if (ag.totalPausedTime) durationMs -= ag.totalPausedTime; durationMs = Math.max(0, durationMs); const hours = Math.floor(durationMs / 3600000), minutes = Math.floor((durationMs % 3600000) / 60000); let catchesHtml = '<h4>Fänge:</h4>'; if (ag.catches.length > 0) { catchesHtml += '<div class="catch-list">'; ag.catches.forEach(catchId => { const c = catches.find(ct => ct.id === catchId); if (c) { const speciesName = c.species === 'other_species' ? c.speciesOther : (fishDatabase[c.species]?.name || c.species); catchesHtml += `<div class="catch-item" style="margin-bottom:0.5rem; cursor:pointer;" onclick="openCatchModal(${c.id})">${c.photo ? `<img src="${c.photo}" class="catch-photo" style="width:50px;height:50px;">` : '<div style="width:50px;height:50px;background:var(--bg-tertiary);border-radius:var(--radius-md);display:flex;align-items:center;justify-content:center;"><i class="fas fa-fish"></i></div>'} <div class="catch-details"><div class="catch-species">${speciesName}</div><div class="catch-info">${c.size}cm</div></div></div>`; }}); catchesHtml += '</div>'; } else { catchesHtml += '<p>Keine Fänge in diesem Angelgang.</p>'; } let weatherHtml = '<h4>Wetter (Start):</h4>'; if(ag.weather) { weatherHtml += `<p>Temp: ${ag.weather.temp ? Math.round(ag.weather.temp) + '°C' : 'N/A'}, Druck: ${ag.weather.pressure ? ag.weather.pressure + 'hPa' : 'N/A'}, Wind: ${ag.weather.wind ? Math.round(ag.weather.wind*3.6) + 'km/h' : 'N/A'}, Wolken: ${ag.weather.clouds !== undefined ? ag.weather.clouds + '%' : 'N/A'}</p>`; } else { weatherHtml += '<p>Keine Daten.</p>'; } content.innerHTML = `<p><strong>Datum:</strong> ${new Date(ag.startTime).toLocaleString('de-DE')}</p><p><strong>Dauer (aktiv):</strong> ${hours}h ${minutes}min</p><p><strong>Zielfisch:</strong> ${fishDatabase[ag.targetFish]?.name || ag.targetFish}</p><p><strong>Methode:</strong> ${getMethodName(ag.method)}</p><p><strong>Ausrüstung:</strong> ${ag.equipment || 'N/A'}</p><p><strong>Gewässer/Spot:</strong> ${displayName}</p>${ag.location ? `<p><strong>Standort (manuell ehem.):</strong> ${ag.location}</p>`: ''}<hr style="margin: 1rem 0;">${weatherHtml}<hr style="margin: 1rem 0;">${catchesHtml}`; modal.classList.add('active'); }
function updateSelectedAngelgangGewaesserInfo(gewaesserId, coords) {
    const displayDiv = document.getElementById('selectedAngelgangGewaesserInfo');
    let html = '';
    if (gewaesserId) {
        html += `Gewässer: <strong>${getGewaesserName(gewaesserId)}</strong>`;
    }
    if (coords) {
        html += `${gewaesserId ? ' | ' : ''}Platz: <strong>${coords}</strong>`;
    }
    if (!html) {
        html = '<span style="color: var(--text-secondary);">Gewässer/Ort auf Karte wählen</span>';
    }
    displayDiv.innerHTML = html;
    document.getElementById('selectedGewaesserHidden').value = gewaesserId || '';
    document.getElementById('angelgangGewaesserCoordsStore').value = coords || '';
}
function updatePlannedDurationDisplay(value) {
    document.getElementById('plannedDurationValueDisplay').textContent = value;
    document.getElementById('plannedDuration').value = value;
}
function incrementPlannedDuration() {
    const slider = document.getElementById('plannedDurationSlider');
    slider.value = Math.min(parseInt(slider.max), parseInt(slider.value) + parseInt(slider.step));
    updatePlannedDurationDisplay(slider.value);
}
function decrementPlannedDuration() {
    const slider = document.getElementById('plannedDurationSlider');
    slider.value = Math.max(parseInt(slider.min), parseInt(slider.value) - parseInt(slider.step));
    updatePlannedDurationDisplay(slider.value);
}
function populateAngelgangEquipmentSetSelect(selectedMethodKey) {
    const select = document.getElementById('angelgangEquipmentSet');
    const groupDiv = document.getElementById('angelgangEquipmentSetGroup');
    select.innerHTML = '<option value="">Kein Set / Manuell</option>';

    if (!selectedMethodKey) {
        groupDiv.style.display = 'none';
        return;
    }
    groupDiv.style.display = 'block';

    // Finde den Anzeigenamen der Angelart basierend auf dem Key
    const selectedMethodDisplayName = Object.keys(methodKeyMap).find(key => methodKeyMap[key] === selectedMethodKey) || selectedMethodKey;

    const relevantSets = userEquipmentSets.filter(set =>
        set.applicableFishingTypes && set.applicableFishingTypes.includes(selectedMethodDisplayName)
    );

    relevantSets.sort((a, b) => a.name.localeCompare(b.name)).forEach(set => {
        select.innerHTML += `<option value="${set.id}">${set.name}</option>`;
    });
}
function applyAngelgangEquipmentSet(setId) {
    const equipmentTextarea = document.getElementById('equipment');
    if (!setId) {
        // Optional: Textarea leeren oder auf Standardwert setzen, falls gewünscht
        // equipmentTextarea.value = "";
        return;
    }
    const selectedSet = userEquipmentSets.find(s => String(s.id) === String(setId));
    if (selectedSet) {
        let equipmentNotes = `Set: ${selectedSet.name}\n`;
        if (selectedSet.items && selectedSet.items.length > 0) {
            equipmentNotes += "Items:\n";
            selectedSet.items.forEach(itemDetail => {
                const catalogItem = equipmentCatalog.find(ci => ci.id === itemDetail.catalogItemId);
                if (catalogItem) {
                    equipmentNotes += `- ${catalogItem.name}${itemDetail.details ? ` (${itemDetail.details})` : ''}\n`;
                }
            });
        }
        equipmentTextarea.value = equipmentNotes.trim();
    }
}


// Catch Functions
function openCatchModal(catchIdToEdit = null) {
    resetCatchFormForNewEntry(); // Stellt sicher, dass Formular immer frisch ist
    const modal = document.getElementById('catchModal');
    const title = document.getElementById('catchModalTitle');
    const form = document.getElementById('catchForm');
    const catchDateInput = document.getElementById('catchDate');

    if (catchIdToEdit) {
        const c = catches.find(ct => String(ct.id) === String(catchIdToEdit));
        if (!c) { console.error("Zu bearbeitender Fang nicht gefunden:", catchIdToEdit); return; }
        isEditingCatch = true;
        document.getElementById('editingCatchIdStore').value = c.id;
        title.textContent = "Fang bearbeiten";

        catchDateInput.value = c.date ? c.date.slice(0,16) : new Date().toISOString().slice(0,16);
        document.getElementById('fishSpecies').value = c.species;
        toggleOtherSpeciesInput(c.species);
        if (c.species === 'other_species' && c.speciesOther) {
            document.getElementById('fishSpeciesOther').value = c.speciesOther;
        }
        document.getElementById('fishSizeSlider').value = c.size || 10; updateFishSizeDisplay(c.size || 10);
        document.getElementById('fishWeightSlider').value = c.weight || 500; updateFishWeightDisplay(c.weight || 500);


        document.getElementById('catchGewaesserIdStore').value = c.gewaesserId || '';
        document.getElementById('catchLocationCoordsStore').value = c.location || '';
        updateSelectedCatchGewaesserInfo(c.gewaesserId, c.location);

        document.getElementById('catchFishingMethod').value = c.method || '';
        updateCatchBaitOptions(c.method || '');
        document.getElementById('catchBait').value = c.bait || '';
        toggleOtherBaitInput(c.bait || '');
        if (c.bait === 'other_bait' && c.baitOther) {
            document.getElementById('catchBaitOther').value = c.baitOther;
        }
        if (c.photo) {
            document.getElementById('catchPreviewImage').src = c.photo;
            document.getElementById('catchPreviewImage').style.display = 'block';
            document.getElementById('catchPhotoUploadArea').style.display = 'none';
            document.getElementById('removeCatchPhotoBtn').style.display = 'inline-block';
        } else {
            removeCatchPhotoPreview();
        }
        document.getElementById('catchNotes').value = c.notes || '';
        form.onsubmit = handleEditCatchSubmit;
    } else {
        isEditingCatch = false;
        document.getElementById('editingCatchIdStore').value = '';
        title.textContent = "Fang dokumentieren";
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const localDateTimeString = `${year}-${month}-${day}T${hours}:${minutes}`;
        catchDateInput.value = localDateTimeString; // Patched by new script logic
        document.getElementById('fishSizeSlider').value = 10; updateFishSizeDisplay(10);
        document.getElementById('fishWeightSlider').value = 500; updateFishWeightDisplay(500);


        if (currentAngelgang) {
            if (currentAngelgang.gewaesser) {
                document.getElementById('catchGewaesserIdStore').value = currentAngelgang.gewaesser;
                const initialCoords = currentAngelgang.gewaesserCoords || getGewaesserLocationById(currentAngelgang.gewaesser) || (currentPosition ? `${currentPosition.lat.toFixed(6)},${currentPosition.lon.toFixed(6)}` : '');
                document.getElementById('catchLocationCoordsStore').value = initialCoords;
                updateSelectedCatchGewaesserInfo(currentAngelgang.gewaesser, initialCoords);
            } else if (currentAngelgang.gewaesserCoords) { // Nur Koordinaten vom Angelgang
                 document.getElementById('catchLocationCoordsStore').value = currentAngelgang.gewaesserCoords;
                 updateSelectedCatchGewaesserInfo(null, currentAngelgang.gewaesserCoords);
            } else if (currentPosition) {
                const initialCoords = `${currentPosition.lat.toFixed(6)},${currentPosition.lon.toFixed(6)}`;
                document.getElementById('catchLocationCoordsStore').value = initialCoords;
                updateSelectedCatchGewaesserInfo(null, initialCoords);
            }
            if (currentAngelgang.method) {
                document.getElementById('catchFishingMethod').value = currentAngelgang.method;
                updateCatchBaitOptions(currentAngelgang.method);
            }
        } else if (currentPosition) {
            const initialCoords = `${currentPosition.lat.toFixed(6)},${currentPosition.lon.toFixed(6)}`;
            document.getElementById('catchLocationCoordsStore').value = initialCoords;
            updateSelectedCatchGewaesserInfo(null, initialCoords);
        } else {
            updateSelectedCatchGewaesserInfo(null, null);
        }
        form.onsubmit = handleCatchSubmit;
    }
    modal.classList.add('active');
}
function closeCatchModal() {
    document.getElementById('catchModal').classList.remove('active');
    resetCatchFormForNewEntry();
}
function resetCatchFormForNewEntry() {
    document.getElementById('catchForm').reset();
    isEditingCatch = false;
    document.getElementById('editingCatchIdStore').value = '';
    document.getElementById('catchModalTitle').textContent = "Fang dokumentieren";
    document.getElementById('fishSpeciesOther').style.display = 'none';
    document.getElementById('catchBaitOther').style.display = 'none';
    removeCatchPhotoPreview();
    updateSelectedCatchGewaesserInfo(null, null);
    document.getElementById('catchGewaesserIdStore').value = '';
    document.getElementById('catchLocationCoordsStore').value = '';
    updateFishSizeDisplay(10);
    updateFishWeightDisplay(500);
    updateCatchBaitOptions('');
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, '0');
    const day = now.getDate().toString().padStart(2, '0');
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const localDateTimeString = `${year}-${month}-${day}T${hours}:${minutes}`;
    document.getElementById('catchDate').value = localDateTimeString; // Patched by new script logic
    document.getElementById('catchForm').onsubmit = handleCatchSubmit;
}
function handleCatchSubmit(e) {
    e.preventDefault();
    const catchData = collectCatchFormData(Date.now());
    if (!catchData) return;

    catches.push(catchData);
    if (currentAngelgang) {
        currentAngelgang.catches.push(catchData.id);
    }
    saveData();
    updateDashboard();
    updateAngelgangDisplay();
    renderCalendar();
    closeCatchModal();
    alert('Fang gespeichert!');
}
function handleEditCatchSubmit(e) {
    e.preventDefault();
    const editingId = parseInt(document.getElementById('editingCatchIdStore').value);
    if (!editingId) { alert("Fehler: Kein Fang zum Bearbeiten ausgewählt."); return; }

    const catchData = collectCatchFormData(editingId);
    if (!catchData) return;

    const index = catches.findIndex(c => c.id === editingId);
    if (index > -1) {
        catches[index] = catchData;
        saveData();
        updateDashboard();
        if (currentAngelgang && currentAngelgang.catches.includes(editingId)) {
            updateAngelgangDisplay();
        }
        renderCalendar();
        closeCatchModal();
        alert('Fang aktualisiert!');
    } else {
        alert("Fehler: Zu bearbeitender Fang nicht in der Liste gefunden.");
    }
}
function collectCatchFormData(id) {
    const species = document.getElementById('fishSpecies').value;
    if (!species) { alert("Bitte Fischart auswählen."); return null; }
    let speciesOther = null;
    if (species === 'other_species') {
        speciesOther = document.getElementById('fishSpeciesOther').value.trim();
        if (!speciesOther) { alert("Bitte die 'Andere Art' spezifizieren."); return null; }
    }
    const baitMethod = document.getElementById('catchFishingMethod').value;
    let bait = document.getElementById('catchBait').value;
    let baitOther = null;
    if (bait === 'other_bait') {
        baitOther = document.getElementById('catchBaitOther').value.trim();
        if (!baitOther) { alert("Bitte den 'Anderen Köder' spezifizieren."); return null; }
    }

    return {
        id: id,
        date: document.getElementById('catchDate').value,
        species: species,
        speciesOther: speciesOther,
        size: parseFloat(document.getElementById('fishSize').value),
        weight: document.getElementById('fishWeight').value ? parseInt(document.getElementById('fishWeight').value) : null,
        gewaesserId: document.getElementById('catchGewaesserIdStore').value || null,
        location: document.getElementById('catchLocationCoordsStore').value || null,
        method: baitMethod,
        bait: bait,
        baitOther: baitOther,
        notes: document.getElementById('catchNotes').value,
        photo: document.getElementById('catchPreviewImage').src.startsWith('data:image') ? document.getElementById('catchPreviewImage').src : null,
        weather: weatherData && weatherData.main ? { temp: weatherData.main.temp, pressure: weatherData.main.pressure, wind: weatherData.wind.speed, clouds: weatherData.clouds?.all } : null
    };
}
function previewCatchPhoto(event) {
    const file = event.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
            document.getElementById('catchPreviewImage').src = e.target.result;
            document.getElementById('catchPreviewImage').style.display = 'block';
            document.getElementById('catchPhotoUploadArea').style.display = 'none';
            document.getElementById('removeCatchPhotoBtn').style.display = 'inline-block';
        };
        reader.readAsDataURL(file);
    }
    event.target.value = null;
}
function removeCatchPhotoPreview() {
    document.getElementById('catchPreviewImage').src = '';
    document.getElementById('catchPreviewImage').style.display = 'none';
    document.getElementById('catchPhotoUploadArea').style.display = 'flex';
    document.getElementById('removeCatchPhotoBtn').style.display = 'none';
    document.getElementById('catchPhotoFileDevice').value = null;
    document.getElementById('catchPhotoFileCamera').value = null;
}
function toggleOtherSpeciesInput(value) {
    document.getElementById('fishSpeciesOther').style.display = (value === 'other_species') ? 'block' : 'none';
}
function updateCatchBaitOptions(selectedMethodKey) {
    const baitSelect = document.getElementById('catchBait');
    const otherBaitInput = document.getElementById('catchBaitOther');
    baitSelect.innerHTML = '';
    otherBaitInput.style.display = 'none';

    const options = baitOptionsByMethod[selectedMethodKey] || baitOptionsByMethod[""];
    options.forEach(opt => {
        const optionEl = document.createElement('option');
        optionEl.value = opt.value;
        optionEl.textContent = opt.text;
        baitSelect.appendChild(optionEl);
    });

    // Option für "Anderer Köder" immer hinzufügen, außer wenn Methode "other_method" ist (da ist es implizit)
    if (selectedMethodKey && selectedMethodKey !== "other_method") {
        const otherOption = document.createElement('option');
        otherOption.value = "other_bait";
        otherOption.textContent = "Anderer Köder...";
        baitSelect.appendChild(otherOption);
    } else if (selectedMethodKey === "other_method") {
        // Bei "Andere Methode" "Anderer Köder" vorselektieren und Inputfeld zeigen
        if (!Array.from(baitSelect.options).some(opt => opt.value === "other_bait")) {
            const otherOption = document.createElement('option');
            otherOption.value = "other_bait";
            otherOption.textContent = "Köder spezifizieren...";
            baitSelect.appendChild(otherOption);
        }
        baitSelect.value = "other_bait";
        toggleOtherBaitInput("other_bait");
    }
}
function toggleOtherBaitInput(value) {
    document.getElementById('catchBaitOther').style.display = (value === 'other_bait') ? 'block' : 'none';
}
function updateFishSizeDisplay(newSize) {
    newSize = parseFloat(newSize);
    const minSize = parseFloat(document.getElementById('fishSizeSlider').min);
    const maxSize = parseFloat(document.getElementById('fishSizeSlider').max);
    newSize = Math.max(minSize, Math.min(maxSize, newSize));
    newSize = parseFloat(newSize.toFixed(1));

    document.getElementById('fishSizeSlider').value = newSize;
    document.getElementById('fishSizeValueDisplay').textContent = newSize.toFixed(1);
    document.getElementById('fishSize').value = newSize;
}
function incrementFishSize() {
    const slider = document.getElementById('fishSizeSlider');
    let currentValue = parseFloat(slider.value);
    let step = parseFloat(slider.step);
    updateFishSizeDisplay(currentValue + step);
}
function decrementFishSize() {
    const slider = document.getElementById('fishSizeSlider');
    let currentValue = parseFloat(slider.value);
    let step = parseFloat(slider.step);
    updateFishSizeDisplay(currentValue - step);
}
function updateFishWeightDisplay(newWeight) {
    newWeight = parseInt(newWeight);
    const minWeight = parseInt(document.getElementById('fishWeightSlider').min);
    const maxWeight = parseInt(document.getElementById('fishWeightSlider').max);
    newWeight = Math.max(minWeight, Math.min(maxWeight, newWeight));

    document.getElementById('fishWeightSlider').value = newWeight;
    document.getElementById('fishWeightValueDisplay').textContent = newWeight;
    document.getElementById('fishWeight').value = newWeight;
}
function incrementFishWeight() {
    const slider = document.getElementById('fishWeightSlider');
    let currentValue = parseInt(slider.value);
    let step = parseInt(slider.step);
    updateFishWeightDisplay(currentValue + step);
}
function decrementFishWeight() {
    const slider = document.getElementById('fishWeightSlider');
    let currentValue = parseInt(slider.value);
    let step = parseInt(slider.step);
    updateFishWeightDisplay(currentValue - step);
}
function updateSelectedCatchGewaesserInfo(gewaesserId, locationCoords) {
    const infoDiv = document.getElementById('selectedCatchGewaesserInfo');
    let html = '';
    if (gewaesserId) {
        html += `Gewässer: <strong>${getGewaesserName(gewaesserId)}</strong>`;
    }
    if (locationCoords) {
        html += `${gewaesserId ? ' | ' : ''}Fangort: <strong>${locationCoords}</strong>`;
    }
    if (!html) {
        html = '<span style="color: var(--text-secondary);">Kein Gewässer/Ort ausgewählt</span>';
    }
    infoDiv.innerHTML = html;
    document.getElementById('catchGewaesserIdStore').value = gewaesserId || '';
    document.getElementById('catchLocationCoordsStore').value = locationCoords || '';
}


// Universal Map Modal Functions
function openUniversalMapModal(context, targetGewaesserIdFieldId, targetCoordsFieldId, displayCallbackName, showSidebar = true) {
    universalMapContext = context;
    universalMapTargetInputGewaesserId = targetGewaesserIdFieldId;
    universalMapTargetInputCoords = targetCoordsFieldId;
    universalMapTargetDisplayCallback = displayCallbackName;
    universalMapEditingGewaesserId = null; // Reset Bearbeitungs-ID

    const modalTitleEl = document.getElementById('catchLocationMapModalTitle');
    const newSpotSectionTitleEl = document.getElementById('newSpotSectionTitle');
    const newSpotNameLabelEl = document.getElementById('newSpotNameLabel');
    const newSpotNameInputEl = document.getElementById('newSpotNameInput');
    const newSpotInstructionsEl = document.getElementById('newSpotInstructions');
    const newSpotContainerEl = document.getElementById('newSpotNameInputContainer');
    const newGewaesserTypeContainer = document.getElementById('newGewaesserTypeContainer_universalMap');
    const catchMapInstructionsEl = document.getElementById('catchMapInstructions');
    const sidebarEl = document.getElementById('catchMapSidebar');

    if (sidebarEl) sidebarEl.style.display = showSidebar ? 'flex' : 'none';

    newSpotNameInputEl.value = '';
    newSpotNameInputEl.disabled = false;
    if(newGewaesserTypeContainer) {
        document.getElementById('newGewaesserType_universalMap').value = 'spot';
        newGewaesserTypeContainer.style.display = 'none';
    }
    selectedGewaesserForCatchMap = null;
    document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => item.classList.remove('selected-for-catch'));
    if (tempCatchLocationMarker && catchLocationMap) {
        catchLocationMap.removeLayer(tempCatchLocationMarker);
        tempCatchLocationMarker = null;
    }

    let currentGewaesserIdValue, currentCoordsStrValue;

    switch (context) {
        case 'selectCatchLocation':
            modalTitleEl.textContent = "Gewässer auswählen oder neuen Fangort markieren";
            newSpotSectionTitleEl.textContent = "Neuen Spot anlegen";
            newSpotNameLabelEl.textContent = "Name für neuen Spot (optional):";
            newSpotNameInputEl.placeholder = "Z.B. Buhne 5";
            newSpotInstructionsEl.textContent = "Markieren Sie einen Punkt auf der Karte. Der Spot wird automatisch mit Koordinaten benannt, falls kein Name angegeben wird.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            catchMapInstructionsEl.textContent = "Klicken Sie auf die Karte, um einen Fangort zu markieren oder wählen Sie ein Gewässer aus der Liste.";
            currentGewaesserIdValue = document.getElementById(universalMapTargetInputGewaesserId).value;
            currentCoordsStrValue = document.getElementById(universalMapTargetInputCoords).value;
            break;
        case 'selectGewasserForAngelgang':
            modalTitleEl.textContent = "Gewässer für Angelgang auswählen/erstellen";
            newSpotSectionTitleEl.textContent = "Neues Gewässer/Spot anlegen";
            newSpotNameLabelEl.textContent = "Name für neues Gewässer/Spot:";
            newSpotNameInputEl.placeholder = "Z.B. Haussee Abschnitt Nord";
            newSpotInstructionsEl.textContent = "Wählen Sie ein Gewässer aus der Liste oder markieren und benennen Sie ein neues auf der Karte.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            if (newGewaesserTypeContainer) newGewaesserTypeContainer.style.display = 'block';
            catchMapInstructionsEl.textContent = "Wählen Sie ein Gewässer, markieren Sie einen Angelplatz oder legen Sie ein neues Gewässer an.";
            currentGewaesserIdValue = document.getElementById(universalMapTargetInputGewaesserId).value;
            currentCoordsStrValue = document.getElementById(universalMapTargetInputCoords).value;
            break;
        case 'selectGewaesserForTrip':
            modalTitleEl.textContent = "Gewässer für Trip auswählen/erstellen";
            newSpotSectionTitleEl.textContent = "Neues Gewässer anlegen";
            newSpotNameLabelEl.textContent = "Name für neues Gewässer:";
            newSpotNameInputEl.placeholder = "Z.B. Vereinsteich Nord";
            newSpotInstructionsEl.textContent = "Wählen Sie ein Gewässer aus der Liste oder legen Sie ein neues auf der Karte an.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            if (newGewaesserTypeContainer) newGewaesserTypeContainer.style.display = 'block';
            catchMapInstructionsEl.textContent = "Gewässer aus der Liste wählen oder neues auf der Karte anlegen.";
            currentGewaesserIdValue = document.getElementById(universalMapTargetInputGewaesserId) ? document.getElementById(universalMapTargetInputGewaesserId).value : null;
            break;
        case 'createGewaesserViaMap':
            modalTitleEl.textContent = "Position für neues Gewässer festlegen";
            newSpotSectionTitleEl.textContent = "Position festlegen";
            newSpotNameLabelEl.textContent = "Name (wird im Formular eingetragen):";
            newSpotNameInputEl.placeholder = "Name aus Formular übernehmen";
            newSpotNameInputEl.disabled = true;
            newSpotInstructionsEl.textContent = "Markieren Sie die Position des neuen Gewässers auf der Karte.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            catchMapInstructionsEl.textContent = "Klicken Sie auf die Karte, um die Position für das neue Gewässer festzulegen.";
            currentCoordsStrValue = document.getElementById(universalMapTargetInputCoords)?.value;
            newSpotNameInputEl.value = document.getElementById('gewaesserNameInput')?.value || '';
            break;
        case 'manageGewaesserTab':
            modalTitleEl.textContent = "Gewässerübersicht und -verwaltung";
            newSpotSectionTitleEl.textContent = "Neues Gewässer anlegen";
            newSpotNameLabelEl.textContent = "Name des neuen Gewässers:";
            newSpotNameInputEl.placeholder = "Name des Gewässers";
            newSpotInstructionsEl.textContent = "Klicken Sie auf ein Gewässer für Details/Bearbeitung oder legen Sie ein neues an.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            if (newGewaesserTypeContainer) newGewaesserTypeContainer.style.display = 'block';
            catchMapInstructionsEl.textContent = "Gewässer aus Liste wählen/bearbeiten oder neues auf Karte anlegen.";
            break;
        case 'editGewaesserPosition': // Kommt vom alten Gewässer-Modal Bearbeiten-Button
            const gewaesserIdForEdit = universalMapEditingGewaesserId || document.getElementById(universalMapTargetInputGewaesserId)?.value;
            const gewaesserToEdit = gewaesser.find(g => String(g.id) === String(gewaesserIdForEdit));
            modalTitleEl.textContent = `Position für "${gewaesserToEdit?.name || 'Gewässer'}" bearbeiten`;
            newSpotSectionTitleEl.textContent = "Position anpassen";
            newSpotNameLabelEl.textContent = "Gewässername:";
            newSpotNameInputEl.value = gewaesserToEdit?.name || '';
            newSpotNameInputEl.disabled = true;
            newSpotInstructionsEl.textContent = "Verschieben Sie den Marker oder klicken Sie auf eine neue Position.";
            if (newSpotContainerEl) newSpotContainerEl.style.display = 'block';
            catchMapInstructionsEl.textContent = "Neue Position für das Gewässer auf der Karte markieren.";
            currentGewaesserIdValue = gewaesserIdForEdit;
            currentCoordsStrValue = gewaesserToEdit?.location;
            break;
    }

    document.getElementById('catchLocationMapModal').classList.add('active');
    initializeCatchLocationMap();
    populateCatchMapGewaesserList();
    loadInitialStateForUniversalMap(currentGewaesserIdValue, currentCoordsStrValue);
}
function loadInitialStateForUniversalMap(gewaesserId, coordsStr) {
    if (gewaesserId) {
        selectGewaesserInCatchMapList(gewaesserId);
        const gw = gewaesser.find(g => String(g.id) === String(gewaesserId));
        if (gw && gw.location) {
            const [lat, lon] = gw.location.split(',').map(parseFloat);
            if (catchLocationMap) catchLocationMap.setView([lat, lon], 13);
            const markerCoords = coordsStr ? coordsStr.split(',').map(parseFloat) : [lat,lon];
            setTempCatchMarker(markerCoords, `Position für ${gw.name}`);
        } else if (gw) {
             setTempCatchMarker(currentPosition ? [currentPosition.lat, currentPosition.lon] : [50.6, 11.9], `Neue Position für ${gw.name}?`);
        }
    } else if (coordsStr) {
        const [lat, lon] = coordsStr.split(',').map(parseFloat);
        setTempCatchMarker([lat, lon], "Ausgewählte Position");
        if (catchLocationMap) catchLocationMap.setView([lat, lon], 15);
    } else if (currentPosition && catchLocationMap) {
         catchLocationMap.setView([currentPosition.lat, currentPosition.lon], 13);
         setTempCatchMarker([currentPosition.lat, currentPosition.lon], "Aktueller Standort als Start");
    }
}
function closeCatchLocationMapModal() {
    document.getElementById('catchLocationMapModal').classList.remove('active');
    if (tempCatchLocationMarker && catchLocationMap) {
        catchLocationMap.removeLayer(tempCatchLocationMarker);
        tempCatchLocationMarker = null;
    }
    selectedGewaesserForCatchMap = null;
    universalMapEditingGewaesserId = null;
    document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => item.classList.remove('selected-for-catch'));
    document.getElementById('newSpotNameInput').value = '';
    document.getElementById('newSpotNameInput').disabled = false;
    if (catchLocationMap) catchLocationMap.invalidateSize();
}
function initializeCatchLocationMap() {
    if (catchLocationMap) {
        catchLocationMap.invalidateSize();
        loadGewaesserMarkersToUniversalMap();
        return;
    }
    const mapContainer = document.getElementById('catchLeafletMap');
    if (!mapContainer) {console.error("Map container #catchLeafletMap not found"); return;}

    let initialLat = currentPosition ? currentPosition.lat : 50.643464;
    let initialLon = currentPosition ? currentPosition.lon : 11.918244;
    let initialZoom = currentPosition ? 13 : 7;

    catchLocationMap = L.map(mapContainer).setView([initialLat, initialLon], initialZoom);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(catchLocationMap);

    catchLocationMap.on('click', function(e) {
        setTempCatchMarker(e.latlng, "Gewählter Punkt");
        if (universalMapContext !== 'selectCatchLocation') {
             selectedGewaesserForCatchMap = null;
             document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => item.classList.remove('selected-for-catch'));
             if (universalMapContext === 'editGewaesserPosition' && universalMapEditingGewaesserId) {
                 // Do nothing, marker for editing gewaesser remains
             } else {
                document.getElementById('newSpotNameInput').disabled = false;
             }
        }
    });

    loadGewaesserMarkersToUniversalMap();
    setTimeout(() => { if (catchLocationMap) catchLocationMap.invalidateSize() }, 200);
}
function loadGewaesserMarkersToUniversalMap() {
    if (!catchLocationMap) return;
    catchMapGewaeserMarkers.forEach(m => { catchLocationMap.removeLayer(m); });
    catchMapGewaeserMarkers = [];

    gewaesser.forEach(gw => {
        if (gw.location) {
            try {
                const coords = gw.location.split(',').map(c => parseFloat(c.trim()));
                if (coords.length === 2 && !isNaN(coords[0]) && !isNaN(coords[1])) {
                    let markerOptions = { gewaesserId: gw.id, title: gw.name };
                    if (gw.type === 'spot') {
                        markerOptions.icon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-yellow.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
                    } else {
                         markerOptions.icon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
                    }

                    const marker = L.marker(coords, markerOptions)
                        .addTo(catchLocationMap)
                        .bindPopup(`<b>${gw.name}</b> (${getTypeName(gw.type)})<br><button class="btn btn-sm" style="margin-top:5px;" onclick="handleGewaesserMarkerClickUniversalMap('${gw.id}', '${gw.location}')">Auswählen/Details</button>`);
                    catchMapGewaeserMarkers.push(marker);
                }
            } catch (e) { console.error("Fehler beim Marker für Gewässer in UniversalMap:", gw.name, e); }
        }
    });
}
function handleGewaesserMarkerClickUniversalMap(gewaesserId, gewaesserLocation) {
    if (universalMapContext === 'manageGewaesserTab' || (universalMapContext === 'editGewaesserPosition' && String(gewaesserId) === String(universalMapEditingGewaesserId))) {
        const g = gewaesser.find(gw => String(gw.id) === gewaesserId);
        if(g) {
            selectGewaesserInCatchMapList(gewaesserId);
            document.getElementById('newSpotNameInput').value = g.name;
            document.getElementById('newSpotNameInput').disabled = (universalMapContext === 'editGewaesserPosition'); // Nur bei 'manage' editierbar
             if(document.getElementById('newGewaesserTypeContainer_universalMap').style.display !== 'none') {
                 document.getElementById('newGewaesserType_universalMap').value = g.type || 'spot';
            }
            setTempCatchMarker(gewaesserLocation.split(',').map(parseFloat), `Position von ${g.name} bearbeiten`);
            universalMapEditingGewaesserId = gewaesserId;
            if (universalMapContext === 'manageGewaesserTab') {
                alert(`Gewässer "${g.name}" ausgewählt. Passen Sie Name, Typ oder Position an und klicken Sie "Auswahl übernehmen", um zu speichern.`);
            }
        }
    } else {
        selectGewaesserFromCatchMapPopup(gewaesserId, gewaesserLocation);
    }
}

function setTempCatchMarker(latLng, popupText = "Position") {
    if (tempCatchLocationMarker && catchLocationMap) {
        catchLocationMap.removeLayer(tempCatchLocationMarker);
    }
    let markerLatLng = latLng;
    if (latLng.lat && latLng.lng) {
        markerLatLng = [latLng.lat, latLng.lng];
    } else if (!Array.isArray(latLng) || latLng.length !== 2) {
        console.error("Ungültiges Format für setTempCatchMarker:", latLng); return;
    }
    tempCatchLocationMarker = L.marker(markerLatLng, {draggable: true, icon: L.icon({ iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x-red.png', shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] }) }).addTo(catchLocationMap)
        .bindPopup(`<b>${popupText}</b><br>Koordinaten: ${markerLatLng[0].toFixed(5)}, ${markerLatLng[1].toFixed(5)}<br>(Marker ist verschiebbar)`).openPopup();
    tempCatchLocationMarker.on('dragend', function(event){
        const newPos = event.target.getLatLng();
        event.target.setPopupContent(`<b>${popupText}</b><br>Koordinaten: ${newPos.lat.toFixed(5)}, ${newPos.lng.toFixed(5)}<br>(Marker ist verschiebbar)`);
    });
}
function selectGewaesserFromCatchMapPopup(gewaesserId, gewaesserLocation) {
    selectGewaesserInCatchMapList(gewaesserId);
    const [lat, lon] = gewaesserLocation.split(',').map(parseFloat);
    let popupText = `Am Gewässer: ${getGewaesserName(gewaesserId)}`;
    if (universalMapContext === 'selectCatchLocation') popupText = `Fangort bei ${getGewaesserName(gewaesserId)}`;
    setTempCatchMarker([lat,lon], popupText);
    if(catchLocationMap) catchLocationMap.setView([lat, lon], 14);
    document.getElementById('newSpotNameInput').disabled = true;
    universalMapEditingGewaesserId = null;
}
function populateCatchMapGewaesserList() {
    const listDiv = document.getElementById('catchMapGewaesserList');
    listDiv.innerHTML = '';
    if (gewaesser.length === 0) {
        listDiv.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.9em;">Keine Gewässer gespeichert.</p>';
        return;
    }
    const sortedGewaesser = [...gewaesser].sort((a,b) => a.name.localeCompare(b.name));
    sortedGewaesser.forEach(gw => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'gewaesser-item';
        itemDiv.dataset.gewaesserId = gw.id;
        itemDiv.innerHTML = `<div class="gewaesser-name">${gw.name}</div><div class="gewaesser-info"><span><i class="fas fa-map-marker-alt"></i> ${gw.location ? 'Pos. vorhanden' : 'Keine Pos.'}</span><span><i class="fas fa-water"></i> ${getTypeName(gw.type)}</span></div>`;
        itemDiv.onclick = () => {
             handleGewaesserMarkerClickUniversalMap(gw.id, gw.location || (currentPosition ? `${currentPosition.lat},${currentPosition.lon}` : ''));
        };
        listDiv.appendChild(itemDiv);
    });
}
function selectGewaesserInCatchMapList(gewaesserId) {
    selectedGewaesserForCatchMap = gewaesserId;
    document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => {
        item.classList.remove('selected-for-catch');
        if (item.dataset.gewaesserId === String(gewaesserId)) {
            item.classList.add('selected-for-catch');
        }
    });
}
async function searchCatchMapLocation() {
    const query = document.getElementById('catchMapLocationSearchInput').value;
    if (!query.trim() || !catchLocationMap) return;
    try {
        const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`);
        if (!response.ok) throw new Error(`Nominatim API Error: ${response.status}`);
        const data = await response.json();
        if (data && data.length > 0) {
            const result = data[0];
            const latLng = [parseFloat(result.lat), parseFloat(result.lon)];
            catchLocationMap.setView(latLng, 13);
            setTempCatchMarker(latLng, `Gesuchter Ort: ${result.display_name.substring(0,30)}...`);
            selectedGewaesserForCatchMap = null;
            document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => item.classList.remove('selected-for-catch'));
            document.getElementById('newSpotNameInput').disabled = false;
            universalMapEditingGewaesserId = null;
        } else { alert("Ort nicht gefunden."); }
    } catch (error) { console.error("Fehler bei der Ortssuche (UniversalMap):", error); alert("Fehler bei der Ortssuche."); }
}
function useCurrentGPSForCatchMap() {
    if (navigator.geolocation && catchLocationMap) {
        navigator.geolocation.getCurrentPosition(
            pos => {
                const latLng = [pos.coords.latitude, pos.coords.longitude];
                catchLocationMap.setView(latLng, 15);
                setTempCatchMarker(latLng, "Aktuelle GPS Position");
                selectedGewaesserForCatchMap = null;
                document.querySelectorAll('#catchMapGewaesserList .gewaesser-item').forEach(item => item.classList.remove('selected-for-catch'));
                document.getElementById('newSpotNameInput').disabled = false;
                universalMapEditingGewaesserId = null;
            },
            err => alert('GPS nicht verfügbar: ' + err.message)
        );
    } else {
        alert('Geolocation nicht unterstützt oder Karte nicht initialisiert.');
    }
}
function saveCatchLocationFromMap() {
    let gewaesserIdToStore = selectedGewaesserForCatchMap || universalMapEditingGewaesserId || null;
    let locationCoordsToStore = null;
    let newSpotNameFromInput = document.getElementById('newSpotNameInput').value.trim();
    let newGewaesserType = document.getElementById('newGewaesserType_universalMap').value;

   // Specific handling for selecting a Gewässer for a trip plan.
   if (universalMapContext === 'selectGewaesserForTrip') {
       if (tempCatchLocationMarker) { // Get coords if marker exists
           const pos = tempCatchLocationMarker.getLatLng();
           locationCoordsToStore = `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`;
       }

       // Validate: A Gewässer must be selected, or a new one marked, named, and its location available.
       if (!gewaesserIdToStore && !(newSpotNameFromInput && locationCoordsToStore)) {
           alert("Für die Trip-Planung: Bitte ein Gewässer auswählen oder einen neuen Spot auf der Karte markieren UND benennen (Position muss markiert sein).");
           return;
       }

       // Handle creation of a new Gewässer/Spot if marked on map, named, and location is available.
       if (!gewaesserIdToStore && newSpotNameFromInput && locationCoordsToStore) {
           const newGewaesserData = {
               id: Date.now(), name: newSpotNameFromInput, type: newGewaesserType, location: locationCoordsToStore, // Ensure locationCoordsToStore is used
               fishTypes: [], notes: `Angelegt für Trip-Planung via Karte.`, size: '', depth: null
           };
           gewaesser.push(newGewaesserData); // Add to global data
           gewaesserIdToStore = newGewaesserData.id; // Use the new ID
           saveData(); // Persist changes
           populateGewaesserSelects(); // Update dropdowns in other forms
           updateGewaesserList();      // Update the main Gewässer list display
           if(map && document.getElementById('gewaesser-tab').classList.contains('active')) addGewaesserToMap(newGewaesserData);
           loadGewaesserMarkersToUniversalMap(); populateCatchMapGewaesserList();
           alert(`Neues Gewässer/Spot "${newGewaesserData.name}" wurde angelegt und für den Trip ausgewählt.`);
       } else if (!gewaesserIdToStore) {
            alert("Bitte wählen Sie ein bestehendes Gewässer aus oder legen Sie ein neues an, indem Sie einen Punkt markieren UND einen Namen vergeben.");
            return;
       }

       // Update the target input field in the trip planning form with the selected Gewässer ID.
       if (universalMapTargetInputGewaesserId && gewaesserIdToStore) {
           document.getElementById(universalMapTargetInputGewaesserId).value = gewaesserIdToStore;
       }

       // Call the specified callback function to update the UI in the trip planning form.
       if (universalMapTargetDisplayCallback && typeof window[universalMapTargetDisplayCallback] === 'function') {
           window[universalMapTargetDisplayCallback](gewaesserIdToStore, null);
       }

       closeCatchLocationMapModal();
       return;
   }

    if (tempCatchLocationMarker) {
        const pos = tempCatchLocationMarker.getLatLng();
        locationCoordsToStore = `${pos.lat.toFixed(6)},${pos.lng.toFixed(6)}`;
    }

    if (!gewaesserIdToStore && !locationCoordsToStore && universalMapContext !== 'createGewaesserViaMap') {
        alert("Bitte einen Punkt auf der Karte markieren oder ein Gewässer aus der Liste wählen."); return;
    }
    if (universalMapContext === 'createGewaesserViaMap' && !locationCoordsToStore) {
        alert("Bitte einen Punkt auf der Karte für das neue Gewässer markieren."); return;
    }


    if (universalMapEditingGewaesserId && gewaesserIdToStore === universalMapEditingGewaesserId) {
        const gIndex = gewaesser.findIndex(g => String(g.id) === String(universalMapEditingGewaesserId));
        if (gIndex > -1) {
            if(newSpotNameFromInput && !document.getElementById('newSpotNameInput').disabled) gewaesser[gIndex].name = newSpotNameFromInput;
            if(locationCoordsToStore) gewaesser[gIndex].location = locationCoordsToStore;
            if(document.getElementById('newGewaesserTypeContainer_universalMap').style.display !== 'none') {
                 gewaesser[gIndex].type = newGewaesserType;
            }
            saveData();
            populateGewaesserSelects(); updateGewaesserList();
            if (map) {
                 const mainMapMarker = gewaesserMarkers.find(m => String(m.options.gewaesserId) === String(gewaesser[gIndex].id));
                 if(mainMapMarker && gewaesser[gIndex].location) {
                    mainMapMarker.setLatLng(gewaesser[gIndex].location.split(',').map(parseFloat));
                    mainMapMarker.setPopupContent(`<strong>${gewaesser[gIndex].name}</strong><br>${getTypeName(gewaesser[gIndex].type)}<br><button class="btn btn-sm" onclick="showGewaesserDetails('${gewaesser[gIndex].id}')">Details</button>`);
                 } else if (mainMapMarker && !gewaesser[gIndex].location) { map.removeLayer(mainMapMarker); gewaesserMarkers = gewaesserMarkers.filter(m => String(m.options.gewaesserId) !== String(gewaesser[gIndex].id));}
                 else if (!mainMapMarker && gewaesser[gIndex].location) { addGewaesserToMap(gewaesser[gIndex]); }
            }
            loadGewaesserMarkersToUniversalMap(); populateCatchMapGewaesserList();
            alert(`Gewässer "${gewaesser[gIndex].name}" aktualisiert.`);
            if(universalMapContext === 'manageGewaesserTab' || universalMapContext === 'editGewaesserPosition') { closeCatchLocationMapModal(); return; }
        }
    } else if (!gewaesserIdToStore && locationCoordsToStore && (universalMapContext === 'selectGewasserForAngelgang' || universalMapContext === 'createGewaesserViaMap' || universalMapContext === 'manageGewaesserTab' || (universalMapContext === 'selectCatchLocation' && newSpotNameFromInput))) {
        let finalNewName = newSpotNameFromInput;
        if (!finalNewName && (universalMapContext === 'selectGewasserForAngelgang' || universalMapContext === 'createGewaesserViaMap' || universalMapContext === 'manageGewaesserTab')) {
             finalNewName = prompt("Bitte geben Sie einen Namen für das neue Gewässer/den neuen Spot ein:", `Spot bei ${locationCoordsToStore}`);
        }

        if (finalNewName) {
            const newGewaesserData = {
                id: Date.now(), name: finalNewName, type: newGewaesserType, location: locationCoordsToStore,
                fishTypes: [], notes: `Automatisch angelegt via Karte (${universalMapContext}).`, size: '', depth: null
            };
            gewaesser.push(newGewaesserData);
            gewaesserIdToStore = newGewaesserData.id;
            saveData();
            populateGewaesserSelects(); updateGewaesserList();
            if(map && document.getElementById('gewaesser-tab').classList.contains('active')) addGewaesserToMap(newGewaesserData);
            loadGewaesserMarkersToUniversalMap(); populateCatchMapGewaesserList();
            alert(`Neues Gewässer/Spot "${finalNewName}" wurde angelegt.`);
        } else if (universalMapContext !== 'selectCatchLocation') {
             alert("Neuanlage abgebrochen, da kein Name vergeben wurde."); return;
        }
    }

    if (universalMapTargetInputGewaesserId) {
        document.getElementById(universalMapTargetInputGewaesserId).value = gewaesserIdToStore || '';
    }
    if (universalMapTargetInputCoords) {
        document.getElementById(universalMapTargetInputCoords).value = locationCoordsToStore || '';
    }
    if (universalMapTargetDisplayCallback && typeof window[universalMapTargetDisplayCallback] === 'function') {
        window[universalMapTargetDisplayCallback](gewaesserIdToStore, locationCoordsToStore);
    }

    closeCatchLocationMapModal();
}
function toggleUniversalMapSidebar() {
    const sidebar = document.getElementById('catchMapSidebar');
    if (sidebar) {
        sidebar.style.display = (sidebar.style.display === 'none' || sidebar.classList.contains('collapsed')) ? 'flex' : 'none';
        sidebar.classList.toggle('collapsed', sidebar.style.display === 'none');
        if (catchLocationMap) setTimeout(() => catchLocationMap.invalidateSize(), 250);
    }
}
function toggleCollapsible(headerElement) {
    const content = headerElement.nextElementSibling;
    const icon = headerElement.querySelector('i.fa-chevron-down');
    content.classList.toggle('open');
    headerElement.classList.toggle('open');
}


// Gewässer Functions
function openGewaesserModal() {
    document.getElementById('gewaesserForm').reset();
    document.getElementById('gewaesserModalTitle').textContent = "Neues Gewässer anlegen";
    document.getElementById('gewaesserModal').classList.add('active');
    destroyGewaesserModalMap();
    updateGewaesserDepthDisplay(document.getElementById('gewaesserDepthSlider').value);
     // Sicherstellen, dass der Map-Button im "alten" Gewässer-Modal den richtigen Kontext setzt
    const mapButtonGewaesserForm = document.querySelector('#gewaesserForm .location-input-group .btn-map');
    if (mapButtonGewaesserForm) {
        mapButtonGewaesserForm.onclick = () => openUniversalMapModal('createGewaesserViaMap', null, 'gewaesserLocationInput', null, false);
    }
    universalMapEditingGewaesserId = null; // Kein Bearbeitungsmodus
}
function closeGewaesserModal() {
    document.getElementById('gewaesserModal').classList.remove('active');
    document.getElementById('gewaesserForm').reset();
    destroyGewaesserModalMap();
}
function initializeGewaesserModalMap() { /* Veraltet */ }
function destroyGewaesserModalMap() { if (newGewaesserMarker) { if (gewaesserModalMap) gewaesserModalMap.removeLayer(newGewaesserMarker); newGewaesserMarker = null; } if (gewaesserModalMap) { gewaesserModalMap.remove(); gewaesserModalMap = null; } }
function handleGewaesserSubmit(e) {
    e.preventDefault();
    const name = document.getElementById('gewaesserNameInput').value;
    if (!name) { alert("Bitte einen Namen für das Gewässer angeben."); return; }
    const fishTypesChecked = Array.from(document.querySelectorAll('#gewaesserForm input[name="fishTypes"]:checked')).map(cb => cb.value);
    const gewaesserData = {
        id: Date.now(),
        name: name,
        type: document.getElementById('gewaesserType').value,
        size: document.getElementById('gewaesserSize').value,
        depth: document.getElementById('gewaesserDepth').value ? parseFloat(document.getElementById('gewaesserDepth').value) : null,
        location: document.getElementById('gewaesserLocationInput').value,
        fishTypes: fishTypesChecked,
        notes: document.getElementById('gewaesserNotes').value
    };
    gewaesser.push(gewaesserData);
    saveData();
    populateGewaesserSelects();
    if(map) addGewaesserToMap(gewaesserData);
    loadGewaesserMarkersToUniversalMap();
    populateCatchMapGewaesserList();
    closeGewaesserModal();
    updateGewaesserList();
    alert('Gewässer angelegt!');
}
function updateGewaesserDepthDisplay(value) {
    document.getElementById('gewaesserDepthValueDisplay').textContent = value;
    document.getElementById('gewaesserDepth').value = value;
}
function incrementGewaesserDepth() {
    const slider = document.getElementById('gewaesserDepthSlider');
    slider.value = (Math.min(parseFloat(slider.max), parseFloat(slider.value) + parseFloat(slider.step))).toFixed(1);
    updateGewaesserDepthDisplay(slider.value);
}
function decrementGewaesserDepth() {
    const slider = document.getElementById('gewaesserDepthSlider');
    slider.value = (Math.max(parseFloat(slider.min), parseFloat(slider.value) - parseFloat(slider.step))).toFixed(1);
    updateGewaesserDepthDisplay(slider.value);
}

function populateGewaesserSelects() {
    const selects = [
        { id: 'tripGewaesser', defaultOption: 'Gewässer wählen...' }
    ];
    selects.forEach(selectInfo => {
        const select = document.getElementById(selectInfo.id);
        if (select) {
            const currentValue = select.value;
            select.innerHTML = `<option value="">${selectInfo.defaultOption}</option>`;
            gewaesser.sort((a, b) => a.name.localeCompare(b.name)).forEach(g => {
                select.innerHTML += `<option value="${g.id}">${g.name}</option>`;
            });
            if (gewaesser.some(g => String(g.id) === String(currentValue))) {
                select.value = currentValue;
            }
        }
    });
}
function updateGewaesserList() { const listDiv = document.getElementById('gewaesserList'); if (!listDiv) return; if (gewaesser.length === 0) { listDiv.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">Noch keine Gewässer angelegt. Nutzen Sie den "Gewässer auf Karte verwalten" Button.</p>'; return; } listDiv.innerHTML = gewaesser.sort((a,b) => a.name.localeCompare(b.name)).map(g => ` <div class="gewaesser-item" onclick="showGewaesserDetails('${g.id}')"> <div class="gewaesser-name">${g.name}</div> <div class="gewaesser-info"> <span><i class="fas fa-water"></i> ${getTypeName(g.type)}</span> ${g.type !== 'spot' ? `<span><i class="fas fa-ruler-horizontal"></i> ${g.size || 'N/A'}</span> <span><i class="fas fa-arrow-down"></i> ${g.depth ? g.depth + 'm' : 'N/A'}</span>` : `<span><i class="fas fa-map-marker-alt"></i> ${g.location || 'N/A'}</span>`} <span><i class="fas fa-fish"></i> ${g.fishTypes.length} Arten</span> </div> </div>`).join(''); }
function showGewaesserDetails(gewaesserId) { const g = gewaesser.find(gw => String(gw.id) === String(gewaesserId)); if (!g) return; const modal = document.getElementById('dayModal'), title = document.getElementById('dayModalTitle'), content = document.getElementById('dayModalContent'); title.textContent = `Gewässer: ${g.name}`; content.innerHTML = `<p><strong>Typ:</strong> ${getTypeName(g.type)}</p>${g.type !== 'spot' ? `<p><strong>Größe:</strong> ${g.size || 'N/A'}</p><p><strong>Max. Tiefe:</strong> ${g.depth ? g.depth + 'm' : 'N/A'}</p>` : ''}<p><strong>Koordinaten:</strong> ${g.location || 'N/A'}</p><p><strong>Fischarten:</strong> ${g.fishTypes.map(f => fishDatabase[f]?.name || capitalizeFirstLetter(f)).join(', ') || 'Keine'}</p><p><strong>Notizen:</strong> ${g.notes || 'Keine'}</p><div style="margin-top: 1rem; display:flex; gap:1rem; justify-content:center;"><button class="btn btn-icon" onclick="openGewaesserModalForEdit('${g.id}'); closeDayModal(); event.stopPropagation();"><i class="fas fa-edit"></i> Bearbeiten (Formular)</button><button class="btn btn-icon" onclick="openUniversalMapForGewaesserEdit('${g.id}'); closeDayModal(); event.stopPropagation();"><i class="fas fa-map-edit"></i> Bearbeiten (Karte)</button><button class="btn btn-danger btn-icon" onclick="deleteGewaesser('${g.id}'); closeDayModal(); event.stopPropagation();"><i class="fas fa-trash"></i> Löschen</button></div>`; modal.classList.add('active'); }
function openGewaesserModalForEdit(gewaesserId) { // Öffnet das Formular-Modal zum Bearbeiten
    const g = gewaesser.find(gw => String(gw.id) === String(gewaesserId));
    if (!g) return;
    openGewaesserModal(); // Ruft das Basis-Modal auf
    document.getElementById('gewaesserModalTitle').textContent = "Gewässer bearbeiten";
    document.getElementById('gewaesserNameInput').value = g.name;
    document.getElementById('gewaesserType').value = g.type;
    document.getElementById('gewaesserSize').value = g.size || '';
    document.getElementById('gewaesserDepthSlider').value = g.depth || 0; updateGewaesserDepthDisplay(g.depth || 0);
    document.getElementById('gewaesserLocationInput').value = g.location || '';
    document.querySelectorAll('#gewaesserForm input[name="fishTypes"]').forEach(cb => {
        cb.checked = g.fishTypes.includes(cb.value);
    });
    document.getElementById('gewaesserNotes').value = g.notes || '';

    // Setze den Bearbeitungsmodus und die ID für das Universal-Karten-Modal
    universalMapEditingGewaesserId = g.id;
    const mapButton = document.querySelector('#gewaesserForm .location-input-group .btn-map');
    if (mapButton) {
        mapButton.onclick = () => openUniversalMapModal('editGewaesserPosition', null, 'gewaesserLocationInput', null, false);
    }

    const form = document.getElementById('gewaesserForm');
    form.onsubmit = function(e) { // Temporärer Submit-Handler für Update
        e.preventDefault();
        const fishTypesChecked = Array.from(document.querySelectorAll('#gewaesserForm input[name="fishTypes"]:checked')).map(cb => cb.value);
        g.name = document.getElementById('gewaesserNameInput').value;
        g.type = document.getElementById('gewaesserType').value;
        g.size = document.getElementById('gewaesserSize').value;
        g.depth = document.getElementById('gewaesserDepth').value ? parseFloat(document.getElementById('gewaesserDepth').value) : null;
        g.location = document.getElementById('gewaesserLocationInput').value;
        g.fishTypes = fishTypesChecked;
        g.notes = document.getElementById('gewaesserNotes').value;

        saveData();
        populateGewaesserSelects();
        if(map) {
            const mainMapMarker = gewaesserMarkers.find(m => String(m.options.gewaesserId) === String(g.id));
            if (mainMapMarker && g.location) {
                const newCoords = g.location.split(',').map(parseFloat);
                if (newCoords.length === 2 && !isNaN(newCoords[0]) && !isNaN(newCoords[1])) {
                     mainMapMarker.setLatLng(newCoords).setPopupContent(`<strong>${g.name}</strong><br>${getTypeName(g.type)}<br><button class="btn btn-sm" onclick="showGewaesserDetails('${g.id}')">Details</button>`);
                }
            } else if (mainMapMarker && !g.location) { map.removeLayer(mainMapMarker); gewaesserMarkers = gewaesserMarkers.filter(m => String(m.options.gewaesserId) !== String(g.id)); }
            else if (!mainMapMarker && g.location) { addGewaesserToMap(g); }
        }
        loadGewaesserMarkersToUniversalMap(); populateCatchMapGewaesserList();
        closeGewaesserModal();
        updateGewaesserList();
        form.onsubmit = handleGewaesserSubmit; // Handler zurücksetzen
        alert('Gewässer aktualisiert!');
        universalMapEditingGewaesserId = null; // Reset
    };
}
function openUniversalMapForGewaesserEdit(gewaesserId) {
    universalMapEditingGewaesserId = gewaesserId; // Setze die ID des zu bearbeitenden Gewässers
    openUniversalMapModal('editGewaesserPosition', null, null, null, true);
}
function deleteGewaesser(gewaesserId) { if (confirm('Gewässer wirklich löschen? Zugehörige Fänge/Angelgänge/geplante Trips verlieren die Verknüpfung.')) { gewaesser = gewaesser.filter(g => String(g.id) !== String(gewaesserId)); const markerToRemove = gewaesserMarkers.find(marker => String(marker.options.gewaesserId) === String(gewaesserId)); if (markerToRemove && map) { map.removeLayer(markerToRemove); } gewaesserMarkers = gewaesserMarkers.filter(marker => String(marker.options.gewaesserId) !== String(gewaesserId)); loadGewaesserMarkersToUniversalMap(); saveData(); populateGewaesserSelects(); updateGewaesserList(); updateDashboard(); populateCatchMapGewaesserList(); } }

// Map Functions (Main Gewässer Tab Map - wird weniger relevant)
function initializeMap() { /* Bleibt für Fallback oder falls doch eine separate Übersichtskarte gewünscht ist */ if (!document.getElementById('gewaesserMap') || typeof L === 'undefined') { console.warn("Hauptkarte kann nicht initialisiert werden."); return; } map = L.map('gewaesserMap').setView([50.643464, 11.918244], 8); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap' }).addTo(map); gewaesser.forEach(addGewaesserToMap); }
function addGewaesserToMap(gData) { if (!gData.location || !map) return; try { const coordsArray = gData.location.split(',').map(c => parseFloat(c.trim())); if (coordsArray.length !== 2 || isNaN(coordsArray[0]) || isNaN(coordsArray[1])) return; const marker = L.marker(L.latLng(coordsArray[0], coordsArray[1]), { gewaesserId: gData.id }).addTo(map).bindPopup(`<strong>${gData.name}</strong><br>${getTypeName(gData.type)}<br><button class="btn btn-sm" onclick="showGewaesserDetails('${gData.id}')">Details</button>`); gewaesserMarkers.push(marker); } catch (e) { console.error("Fehler beim Hinzufügen des Gewässer-Markers zur Hauptkarte:", e, gData); } }
async function searchGewaesserLocation() { /* Suchfunktion für Hauptkarte, falls noch genutzt */ const query = document.getElementById('gewaesserLocationSearch').value; if (!query.trim() || !map) return; try { const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=1`); if (!response.ok) throw new Error(`Nominatim API Error: ${response.status}`); const data = await response.json(); if (data && data.length > 0) { const result = data[0]; map.setView([parseFloat(result.lat), parseFloat(result.lon)], 13); } else { alert("Ort nicht gefunden."); } } catch (error) { console.error("Fehler bei der Ortssuche (Hauptkarte):", error); alert("Fehler bei der Ortssuche."); } }
function openUniversalMapForGewaesserManagement() {
    openUniversalMapModal('manageGewaesserTab', null, null, null, true); // Sidebar anzeigen
}
function getCurrentPositionForGewaesserMap() { /* Für Hauptkarte, falls noch genutzt */ if (map && currentPosition) { map.setView([currentPosition.lat, currentPosition.lon], 13); if (currentPositionMarker) map.removeLayer(currentPositionMarker); currentPositionMarker = L.circleMarker([currentPosition.lat, currentPosition.lon], { radius: 8, color: 'blue', fillColor: '#3498db', fillOpacity: 0.8 }).addTo(map).bindPopup("Aktuelle Position").openOn(map); } else if (map) { alert("Aktuelle Position wird ermittelt oder ist nicht verfügbar."); getCurrentPosition(); } }

// Calendar Functions
function renderCalendar() {
    const grid = document.getElementById('calendarGrid');
    const monthYearEl = document.getElementById('currentMonthYear');
    if (!grid || !monthYearEl) return;

    const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
    const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
    const months = ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
    monthYearEl.textContent = `${months[currentMonth]} ${currentYear}`;
    grid.innerHTML = '';

    const dayHeaders = ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'];
    dayHeaders.forEach(day => grid.innerHTML += `<div class="calendar-day-header">${day}</div>`);

    let startingDayOfWeek = firstDayOfMonth.getDay() - 1; // Montag = 0, Sonntag = 6
    if (startingDayOfWeek < 0) startingDayOfWeek = 6;

    for (let i = 0; i < startingDayOfWeek; i++) {
        grid.innerHTML += `<div class="calendar-day other-month"></div>`;
    }

    const today = new Date();
    const todayString = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;

    for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
        const dayDiv = document.createElement('div');
        dayDiv.className = 'calendar-day';
        const currentDayString = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
        if (currentDayString === todayString) dayDiv.classList.add('today');

        // Finde alle relevanten Einträge für diesen Tag
        const dayAngelgaenge = angelgangs.filter(ag => ag.startTime && ag.startTime.startsWith(currentDayString));
        const dayCatches = catches.filter(c => c.date && c.date.startsWith(currentDayString));
        const isPlannedTrip = plannedTrips.some(trip => trip.date === currentDayString);

        let hasAnyAngelgang = dayAngelgaenge.length > 0;
        // Hat ein Angelgang an diesem Tag einen Fang?
        let hasAngelgangWithCatch = hasAnyAngelgang && dayAngelgaenge.some(ag => ag.catches && ag.catches.length > 0);
        // Ist es ein "Schneider"-Tag (Angelgang ja, aber kein Fang in *irgendeinem* Angelgang des Tages)?
        let isAngelgangSchneider = hasAnyAngelgang && !hasAngelgangWithCatch;

        // Gibt es Fänge, die *nicht* zu einem Angelgang an diesem Tag gehören?
        const angelgangCatchIdsOnThisDay = dayAngelgaenge.flatMap(ag => ag.catches || []);
        let hasCatchNotFromAngelgang = dayCatches.some(c => !angelgangCatchIdsOnThisDay.includes(c.id));

        let markersHTML = '<div class="day-event-markers">';
        let fishIconHTML = ''; // Für das 🐟 Icon

        // 1. Geplanter Trip (Rot)
        if (isPlannedTrip) {
            markersHTML += '<span class="event-marker planned-trip-marker" title="Geplanter Trip"></span>';
            dayDiv.classList.add('has-planned-trip'); // Für CSS-Rand o.ä.
        }

        // 2. Angelgang-spezifische Marker
        if (hasAngelgangWithCatch) {
            markersHTML += '<span class="event-marker angelgang-catch-marker" title="Angelgang mit Fang"></span>';
            fishIconHTML = '🐟'; // Fisch-Icon, da Fang im Angelgang
            dayDiv.classList.add('has-angelgang', 'has-catch'); // Für Randfarben etc.
        } else if (isAngelgangSchneider) {
            markersHTML += '<span class="event-marker angelgang-schneider-marker" title="Angelgang (Schneider)"></span>';
            dayDiv.classList.add('has-angelgang'); // Für Randfarben etc. (aber kein .has-catch)
        }

        // 3. Fisch-Icon für Fänge ohne Angelgang (nur wenn nicht schon durch AngelgangMitFang gesetzt)
        if (hasCatchNotFromAngelgang && !fishIconHTML) {
            fishIconHTML = '🐟';
             // Wenn es einen Nur-Fang gibt und keinen Angelgang, füge Klasse für Rand/Icon hinzu
            if (!hasAnyAngelgang) {
                dayDiv.classList.add('has-catch'); // Stellt sicher, dass auch ein Nur-Fang als "has-catch" für Styling gilt
            }
        }

        markersHTML += '</div>';
        dayDiv.innerHTML = `<div class="day-number">${day}</div>${markersHTML}`;

        // Fisch-Icon hinzufügen, falls gesetzt
        if (fishIconHTML) {
            dayDiv.classList.add('has-catch-icon-display'); // Eigene Klasse für das Styling des Icons
            const fishSpan = document.createElement('span');
            fishSpan.className = 'calendar-day-fish-icon-style'; // Eigene Klasse für das Icon-Styling (siehe CSS-Hinweis oben)
            fishSpan.textContent = fishIconHTML;
            dayDiv.appendChild(fishSpan);
        }

        // CSS Klassen für Ränder: (Die Logik hierfür kann komplex sein, wenn mehrere Zustände gleichzeitig auftreten.
        // Die oben gesetzten .has-angelgang und .has-catch Klassen sind ein Start.)
        // Beispiel: Wenn es einen Angelgang (ggf. Schneider) UND einen separaten Fang gibt:
        if (hasAnyAngelgang && hasCatchNotFromAngelgang) {
            // Hier könntest du eine spezielle Klasse setzen oder dich auf die Kombination von
            // .has-angelgang und .has-catch verlassen (was lila Rand ergeben sollte).
        }


        dayDiv.onclick = () => showDayDetailsForDateString(currentDayString);
        grid.appendChild(dayDiv);
    }

    // Kalenderlegende aktualisieren
    const legendContainer = document.getElementById('calendarLegend');
    if (legendContainer) {
        legendContainer.innerHTML = `
            <div class="legend-item"><span class="event-marker planned-trip-marker"></span> Geplanter Trip</div>
            <div class="legend-item"><span class="event-marker angelgang-catch-marker"></span> Angelgang mit Fang</div>
            <div class="legend-item"><span class="event-marker angelgang-schneider-marker"></span> Angelgang (Schneider)</div>
            <div class="legend-item"><span class="legend-icon" style="font-size: 1.1rem;">🐟</span> Fang (generell)</div>
        `;
    }
}

function previousMonth() { currentMonth--; if (currentMonth < 0) { currentMonth = 11; currentYear--; } renderCalendar(); }
function nextMonth() { currentMonth++; if (currentMonth > 11) { currentMonth = 0; currentYear++; } renderCalendar(); }
function goToToday() { const today = new Date(); currentMonth = today.getMonth(); currentYear = today.getFullYear(); renderCalendar(); }
function showDayDetailsForDateString(dateString) {
    const modal = document.getElementById('dayModal');
    const title = document.getElementById('dayModalTitle');
    const content = document.getElementById('dayModalContent');
    const [year, month, day] = dateString.split('-').map(Number);
    const displayDate = new Date(year, month - 1, day);
    title.textContent = displayDate.toLocaleDateString('de-DE', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

    const dayCatches = catches.filter(c => c.date && c.date.startsWith(dateString));
    const dayAngelgaenge = angelgangs.filter(a => a.startTime && a.startTime.startsWith(dateString));
    const dayPlannedTrips = plannedTrips.filter(trip => trip.date === dateString);

    let html = '';
    if (dayAngelgaenge.length > 0) { html += '<h3>Angelgänge</h3><div class="catch-list">'; dayAngelgaenge.forEach(ag => { let durMs = new Date(ag.endTime) - new Date(ag.startTime); if(ag.totalPausedTime) durMs -= ag.totalPausedTime; durMs = Math.max(0, durMs); const h = Math.floor(durMs/3600000), m = Math.floor((durMs%3600000)/60000); const displayName = getGewaesserName(ag.gewaesser) || `Spot ${ag.gewaesserCoords ? `(${ag.gewaesserCoords})` : '(Keine Koordinaten)'}`; html += `<div class="catch-item" style="cursor:pointer;" onclick="showAngelgangDetails('${ag.id}')"><div class="catch-details"><div class="catch-species">${displayName} (${fishDatabase[ag.targetFish]?.name||ag.targetFish})</div><div class="catch-info">${h}h ${m}min | ${ag.catches.length} Fänge</div></div></div>`; }); html += '</div>'; }
    if (dayCatches.length > 0) { html += '<h3 style="margin-top:1rem;">Fänge (alle)</h3><div class="catch-list">'; dayCatches.forEach(c => { const speciesName = c.species === 'other_species' ? c.speciesOther : (fishDatabase[c.species]?.name || capitalizeFirstLetter(c.species)); html += `<div class="catch-item" style="cursor:pointer;" onclick="openCatchModal(${c.id})">${c.photo?`<img src="${c.photo}" class="catch-photo">`:'<div class="catch-photo" style="background:var(--bg-tertiary);display:flex;align-items:center;justify-content:center;"><i class="fas fa-fish"></i></div>'}<div class="catch-details"><div class="catch-species">${speciesName}</div><div class="catch-info">${c.size}cm ${c.weight?`| ${c.weight}g`:''}</div></div></div>`; }); html += '</div>'; }
    html += `<h3 style="margin-top:1rem;">Geplante Trips <button class="btn btn-sm btn-icon" style="font-size:0.8em; padding: 0.3rem 0.6rem; vertical-align:middle;" onclick="openTripPlanningModal('${dateString}', null)" title="Trip für diesen Tag planen"><i class="fas fa-plus"></i></button></h3>`;
    if (dayPlannedTrips.length > 0) { html += '<div class="catch-list">'; dayPlannedTrips.forEach(trip => { const gewaesserName = getGewaesserName(trip.gewaesserId); html += `<div class="catch-item" style="border-left: 5px solid var(--calendar-planned-trip-color);"><div class="catch-details" style="flex-grow:1;"><div class="catch-species" style="font-weight:bold;">${getMethodName(trip.type)} an ${gewaesserName}</div><div class="catch-info">${trip.time ? `Uhrzeit: ${trip.time} | ` : ''}Teilnehmer: ${trip.participants.map(p => p.name).join(', ') || 'Niemand'}</div>${trip.notes ? `<p style="font-size:0.85em; margin-top:0.25rem;"><em>Notiz: ${trip.notes}</em></p>` : ''}${trip.equipment && trip.equipment.length > 0 ? `<p style="font-size:0.85em; margin-top:0.25rem;">Packliste: ${trip.equipment.map(eq => eq.name + (eq.broughtBy ? ' ('+eq.broughtBy+')':'')).join(', ')}</p>`: ''}</div><div class="catch-actions"><button class="btn btn-icon btn-sm" onclick="openTripPlanningModal(null, ${trip.id}); event.stopPropagation();"><i class="fas fa-edit"></i></button><button class="btn btn-icon btn-danger btn-sm" onclick="deletePlannedTrip(${trip.id}); event.stopPropagation();"><i class="fas fa-trash"></i></button></div></div>`; }); html += '</div>'; }
    else { html += '<p style="text-align:center;color:var(--text-secondary);">Keine Trips für diesen Tag geplant.</p>'; }
    if (dayCatches.length === 0 && dayAngelgaenge.length === 0 && dayPlannedTrips.length === 0) { html = `<p style="text-align:center;color:var(--text-secondary);">Keine Einträge für diesen Tag.</p><div style="text-align:center; margin-top:1.5rem;"><button class="btn" onclick="openTripPlanningModal('${dateString}', null)"><i class="fas fa-plus"></i> Trip für diesen Tag planen</button></div>`; }
    content.innerHTML = html; modal.classList.add('active');
}
function closeDayModal() { document.getElementById('dayModal').classList.remove('active'); }

// Dashboard Functions
function updateDashboard() { const tcEl = document.getElementById('totalCatches'), tmEl = document.getElementById('thisMonth'), bfEl = document.getElementById('bestFish'); if (tcEl) tcEl.textContent = catches.length; if (tmEl) tmEl.textContent = catches.filter(c => c.date && new Date(c.date).getMonth() === new Date().getMonth() && new Date(c.date).getFullYear() === new Date().getFullYear()).length; if (bfEl) { const fc = {}; catches.forEach(c => {const key = c.species === 'other_species' ? c.speciesOther : c.species; fc[key]=(fc[key]||0)+1;}); const bf = Object.entries(fc).sort((a,b)=>b[1]-a[1])[0]; bfEl.textContent = bf ? (fishDatabase[bf[0]]?.name || capitalizeFirstLetter(bf[0])) : '-'; } updateCatchList(); updateAngelgangDisplay(); updateProbabilities(); }
function updateCatchList() { const listDiv = document.getElementById('catchList'); if (!listDiv) return; if (catches.length === 0) { listDiv.innerHTML = '<p style="text-align:center;color:var(--text-secondary);">Keine Fänge vorhanden.</p>'; return; } const recent = [...catches].sort((a,b)=>new Date(b.date)-new Date(a.date)).slice(0,5); listDiv.innerHTML = recent.map(c => { const speciesName = c.species === 'other_species' ? c.speciesOther : (fishDatabase[c.species]?.name || capitalizeFirstLetter(c.species)); return ` <div class="catch-item" onclick="openCatchModal(${c.id})"> ${c.photo ? `<img src="${c.photo}" class="catch-photo">` : '<div class="catch-photo" style="background:var(--bg-tertiary);display:flex;align-items:center;justify-content:center;"><i class="fas fa-fish"></i></div>'} <div class="catch-details"> <div class="catch-species">${speciesName}</div> <div class="catch-info">${c.date ? new Date(c.date).toLocaleDateString('de-DE') : 'N/A'} | ${c.size}cm ${c.weight?`| ${c.weight}g`:''} | ${getGewaesserName(c.gewaesserId)}</div> </div> <div class="catch-actions"> <button class="btn btn-icon btn-sm" onclick="openCatchModal(${c.id}); event.stopPropagation();"><i class="fas fa-edit"></i></button> <button class="btn btn-icon btn-danger btn-sm" onclick="deleteCatch(${c.id}); event.stopPropagation();"><i class="fas fa-trash"></i></button> </div> </div>`}).join(''); }
function deleteCatch(catchId) { if (confirm('Fang wirklich löschen?')) { catches = catches.filter(c => c.id != catchId); angelgangs.forEach(ag => ag.catches = ag.catches.filter(id => id != catchId)); if (currentAngelgang) currentAngelgang.catches = currentAngelgang.catches.filter(id => id != catchId); saveData(); updateDashboard(); updateAngelgangDisplay(); renderCalendar(); } }

// Statistics Functions
function updateStatistics() { const content = document.getElementById('statisticsContent'); if (!content) return; if (catches.length === 0) { content.innerHTML = '<p style="text-align:center;color:var(--text-secondary);">Keine Statistiken vorhanden.</p>'; return; } const stats = calculateDetailedStatistics(); content.innerHTML = `<div class="stats-grid" style="margin-bottom:1rem;"><div class="stat-card"><div class="stat-number">${stats.totalCatches}</div><div class="stat-label">Gesamt Fänge</div></div><div class="stat-card"><div class="stat-number">${stats.uniqueSpecies}</div><div class="stat-label">Arten</div></div><div class="stat-card"><div class="stat-number">${stats.avgSize.toFixed(1)}</div><div class="stat-label">Ø Größe (cm)</div></div><div class="stat-card"><div class="stat-number">${stats.totalAngelgangs}</div><div class="stat-label">Angelgänge</div></div></div><h3>Nach Art</h3><div style="margin-bottom:1rem;">${Object.entries(stats.speciesStats).sort((a,b)=>b[1].count-a[1].count).map(([s,d])=>`<div class="fish-probability" style="cursor:default;"><div class="fish-info"><div class="fish-icon">${fishDatabase[s]?.icon||'🐟'}</div><div><div class="fish-name">${d.displayName}</div><div class="fish-score">${d.count} Fänge | Ø${d.avgSize.toFixed(1)}cm</div></div></div><div style="text-align:right;"><strong>${d.largest}cm</strong><div style="font-size:0.8rem;color:var(--text-secondary);">Rekord</div></div></div>`).join('')}</div><h3>Beste Zeiten</h3><div class="solunar-times">${Object.entries(stats.bestTimes).sort((a,b)=>b[1]-a[1]).slice(0,4).map(([t,c])=>`<div class="solunar-period"><span class="solunar-label">${getTimeOfDayName(t)}</span><span class="solunar-time">${c} Fänge</span></div>`).join('')||'<p>N/A</p>'}</div><h3 style="margin-top:1rem;">Top Gewässer</h3><div>${Object.entries(stats.gewaesserStats).sort((a,b)=>b[1]-a[1]).slice(0,5).map(([gid,c])=>`<div class="gewaesser-item" style="cursor:default;"><div class="gewaesser-name">${getGewaesserName(gid)}</div><div class="gewaesser-info"><span>${c} Fänge</span></div></div>`).join('')||'<p>N/A</p>'}</div>`; }
function calculateDetailedStatistics() { const stats = { totalCatches:catches.length, uniqueSpecies:0, avgSize:catches.length>0?catches.reduce((s,c)=>s+c.size,0)/catches.length:0, totalAngelgangs:angelgangs.length, speciesStats:{}, bestTimes:{}, gewaesserStats:{} }; const uniqueSpeciesSet = new Set(); catches.forEach(c=>{ const speciesKey = c.species === 'other_species' ? c.speciesOther : c.species; uniqueSpeciesSet.add(speciesKey); const displayName = c.species === 'other_species' ? c.speciesOther : (fishDatabase[c.species]?.name || capitalizeFirstLetter(c.species)); stats.speciesStats[speciesKey]=(stats.speciesStats[speciesKey]||{count:0,totalSize:0,largest:0, displayName: displayName}); stats.speciesStats[speciesKey].count++; stats.speciesStats[speciesKey].totalSize+=c.size; stats.speciesStats[speciesKey].largest=Math.max(stats.speciesStats[speciesKey].largest,c.size); if (c.date) { const timeOfDay=getTimeOfDay(new Date(c.date).getHours()); stats.bestTimes[timeOfDay]=(stats.bestTimes[timeOfDay]||0)+1; } if(c.gewaesserId)stats.gewaesserStats[c.gewaesserId]=(stats.gewaesserStats[c.gewaesserId]||0)+1; }); stats.uniqueSpecies = uniqueSpeciesSet.size; Object.values(stats.speciesStats).forEach(sD=>sD.avgSize=sD.count>0?sD.totalSize/sD.count:0); return stats; }

// Location Functions
function getCurrentPosition() { if (navigator.geolocation) { navigator.geolocation.getCurrentPosition( pos => { currentPosition = {lat:pos.coords.latitude,lon:pos.coords.longitude}; updateWeather(); if(map) { map.setView([currentPosition.lat,currentPosition.lon],13); if (currentPositionMarker) map.removeLayer(currentPositionMarker); currentPositionMarker = L.circleMarker([currentPosition.lat, currentPosition.lon], { radius: 8, color: 'blue', fillColor: '#3498db', fillOpacity: 0.8 }).addTo(map).bindPopup("Aktuelle Position"); } }, err => { console.error('GPS Fehler:',err); currentPosition={lat:50.643464,lon:11.918244}; updateWeather(); if(map) map.setView([currentPosition.lat,currentPosition.lon],7); } ); } else { currentPosition={lat:50.643464,lon:11.918244}; updateWeather(); if(map) map.setView([currentPosition.lat,currentPosition.lon],7); } }
function getGewaesserLocationById(id) {
    const gw = gewaesser.find(g => String(g.id) === String(id));
    return gw ? gw.location : null;
}

// Import/Export Functions
function exportData() { const dataToExport = { catches, angelgangs, gewaesser, userEquipmentSets, plannedTrips, fishingTypes, equipmentCatalog }; const dataStr = JSON.stringify(dataToExport, null, 2); const blob = new Blob([dataStr], {type: "application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `angelverwaltung_export_${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert('Daten exportiert!'); }
function importData() { const fileInput = document.getElementById('importFile'); if (!fileInput.files || fileInput.files.length === 0) { alert('Bitte Datei wählen.'); return; } const file = fileInput.files[0]; const reader = new FileReader(); reader.onload = function(event) { try { const importedData = JSON.parse(event.target.result); if (confirm('Bestehende Daten überschreiben?')) { catches = importedData.catches || []; angelgangs = importedData.angelgangs || []; gewaesser = importedData.gewaesser || []; userEquipmentSets = importedData.userEquipmentSets || []; plannedTrips = importedData.plannedTrips || []; const defaultFT = ["Spinnfischen", "Grundangeln", "Posenfischen", "Fliegenfischen", "Feederangeln", "Köderfischen", "Ultraleicht Angeln", "Friedfisch", "Raubfisch", "Allgemein", "Andere Methode"]; fishingTypes = importedData.fishingTypes || defaultFT; defaultFT.forEach(dft => { if (!fishingTypes.includes(dft)) fishingTypes.push(dft);}); const defaultEQ = [ { id: 'rute_spinn_std', name: "Spinnrute Standard", category: "Spinnfischen" }]; equipmentCatalog = importedData.equipmentCatalog || defaultEQ; saveData(); populateGewaesserSelects(); populateAllFishingTypeSelects(); updateDashboard(); renderCalendar(); updateGewaesserList(); updateAngelgangHistory(); updateAngelgangContent(); updateStatistics(); updateApiKeyStatus(); updateSettingsTabViews(); updateUserEquipmentSetsDisplay(); if(map) { gewaesserMarkers.forEach(marker => map.removeLayer(marker)); gewaesserMarkers = []; gewaesser.forEach(addGewaesserToMap); } loadGewaesserMarkersToUniversalMap(); populateCatchMapGewaesserList(); alert('Daten importiert!'); } } catch (e) { alert('Fehler beim Parsen: ' + e.message); console.error("Import Fehler:", e); } }; reader.readAsText(file); }

// Trip Planning Functions
let currentEditingTripId = null;
function openTripPlanningModal(dateString = null, tripToEditId = null) {
    const modal = document.getElementById('tripPlanningModal');
    const form = document.getElementById('tripPlanningForm');
    form.reset();
    currentEditingTripId = tripToEditId;
    document.getElementById('tripId').value = tripToEditId || '';
    document.getElementById('tripParticipantsContainer').innerHTML = '';
    document.getElementById('tripEquipmentContainer').innerHTML = '';
    participantColorIndex = 0;

    populateGewaesserSelects();
    populateAllFishingTypeSelects(); // Stellt sicher, dass alle Selects aktuell sind

    if (tripToEditId) {
        const trip = plannedTrips.find(t => t.id === tripToEditId);
        if (trip) {
            document.getElementById('tripPlanningModalTitle').textContent = "Angel-Trip bearbeiten";
            document.getElementById('tripDate').value = trip.date;
            if (trip.time) document.getElementById('tripTime').value = trip.time;
            // Hier den Anzeigenamen der Angelart setzen, nicht den internen Key, falls unterschiedlich
            const tripTypeDisplayName = Object.keys(methodKeyMap).find(key => methodKeyMap[key] === trip.type) || trip.type;
            document.getElementById('tripTypeSelect').value = tripTypeDisplayName;
            document.getElementById('tripGewaesser').value = trip.gewaesserId;
            document.getElementById('tripNotes').value = trip.notes || '';
            document.getElementById('equipmentFilterType').value = tripTypeDisplayName; // Setzt Filter auf die Angelart des Trips

            trip.participants.forEach(p => addTripParticipantField(p.name, p.color));
            populateTripEquipmentList(tripTypeDisplayName, trip.equipment || []);
        } else {
            console.error("Trip zum Bearbeiten nicht gefunden:", tripToEditId);
            document.getElementById('tripPlanningModalTitle').textContent = "Angel-Trip planen";
            document.getElementById('tripDate').value = dateString || new Date().toISOString().split('T')[0];
            addTripParticipantField();
            populateTripEquipmentList(document.getElementById('tripTypeSelect').value);
        }
    } else {
        document.getElementById('tripPlanningModalTitle').textContent = "Angel-Trip planen";
        document.getElementById('tripDate').value = dateString || new Date().toISOString().split('T')[0];
        addTripParticipantField();
        populateTripEquipmentList(document.getElementById('tripTypeSelect').value);
    }
    modal.classList.add('active');
}
function closeTripPlanningModal() {
    document.getElementById('tripPlanningModal').classList.remove('active');
    currentEditingTripId = null;
}

function populateAllFishingTypeSelects() {
    fishingTypes.sort();
    const selectsToPopulate = [
        { id: 'tripTypeSelect', defaultOption: 'Angelart wählen...' },
        { id: 'newEquipmentItemCategorySelect', defaultOption: 'Kategorie wählen...' },
        { id: 'equipmentFilterType', defaultOption: 'Alle Items anzeigen', specialFirstOption: 'All' },
        { id: 'newEquipmentCatalogCategorySettingSelect', defaultOption: 'Kategorie wählen...' },
        { id: 'fishingMethod', defaultOption: 'Angelmethode wählen...'}, // Für Angelgang-Start
        { id: 'catchFishingMethod', defaultOption: 'Angelmethode wählen...'}, // Für Fang-Modal
    ];

    selectsToPopulate.forEach(s => {
        const selectElement = document.getElementById(s.id);
        if (selectElement) {
            const currentValue = selectElement.value; // Alten Wert merken
            selectElement.innerHTML = `<option value="">${s.defaultOption}</option>`;
            if (s.specialFirstOption) { // Für Filter "Alle Items anzeigen"
                selectElement.innerHTML = `<option value="${s.specialFirstOption}">${s.defaultOption}</option>`;
            }
            fishingTypes.forEach(typeDisplayName => {
                let valueForOption = typeDisplayName; // Standard: Anzeigename ist Wert
                // Für Angelgang & Fang Methode den internen Key verwenden, falls vorhanden
                if ((s.id === 'fishingMethod' || s.id === 'catchFishingMethod') && methodKeyMap[typeDisplayName]) {
                    valueForOption = methodKeyMap[typeDisplayName];
                }
                selectElement.innerHTML += `<option value="${valueForOption}">${typeDisplayName}</option>`;
            });

            // Bei Angelmethoden-Selects "Andere Methode" sicherstellen
            if ((s.id === 'fishingMethod' || s.id === 'catchFishingMethod') && !fishingTypes.includes("Andere Methode")) {
                 // Nur hinzufügen, wenn nicht schon durch fishingTypes abgedeckt
                 if (!Array.from(selectElement.options).some(opt => opt.value === 'other_method')) {
                    selectElement.innerHTML += `<option value="other_method">Andere Methode</option>`;
                 }
            }


            // Alten Wert wiederherstellen, falls möglich
            if (Array.from(selectElement.options).some(opt => opt.value === currentValue)) {
                selectElement.value = currentValue;
            } else if (s.id === 'equipmentFilterType' && s.specialFirstOption) {
                 selectElement.value = s.specialFirstOption; // Default für Filter
            }
        }
    });
     // Populate Checkboxen für User Set Applicable Types
    const userSetApplicableTypesContainer = document.getElementById('userSetApplicableFishingTypesContainer');
    if (userSetApplicableTypesContainer) {
        userSetApplicableTypesContainer.innerHTML = '';
        fishingTypes.forEach(type => {
            if (type !== "Allgemein" && type !== "Andere Methode") { // "Allgemein" und "Andere Methode" hier nicht relevant
                const checkboxId = `userSetType_${type.replace(/\s+/g, '_')}`;
                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.innerHTML = `<input type="checkbox" id="${checkboxId}" name="userSetApplicableType" value="${type}"> ${type}`;
                userSetApplicableTypesContainer.appendChild(label);
            }
        });
    }
}
function addFishingTypeFromTripModal() {
    const input = document.getElementById('newTripTypeInput');
    const newType = capitalizeFirstLetter(input.value.trim());
    if (newType && !fishingTypes.includes(newType)) {
        fishingTypes.push(newType);
        saveData();
        populateAllFishingTypeSelects();
        document.getElementById('tripTypeSelect').value = newType; // Anzeigename
        populateTripEquipmentList(newType, getCurrentSelectedEquipment());
        updateSettingsTabViews();
        input.value = '';
    } else if (fishingTypes.includes(newType)) {
        alert("Diese Angelart existiert bereits.");
        document.getElementById('tripTypeSelect').value = newType; // Anzeigename
        input.value = '';
    }
}
function addTripParticipantField(name = '', color = '') {
    const container = document.getElementById('tripParticipantsContainer');
    const div = document.createElement('div');
    div.className = 'participant-field';

    const assignedColor = color || defaultParticipantColors[participantColorIndex % defaultParticipantColors.length];
    participantColorIndex++;

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'form-control participant-name';
    nameInput.placeholder = 'Name';
    nameInput.value = name;
    nameInput.style.flexGrow = '1';
    nameInput.addEventListener('input', () => populateTripEquipmentList(document.getElementById('equipmentFilterType').value, getCurrentSelectedEquipment()));

    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    colorInput.className = 'form-control participant-color';
    colorInput.value = assignedColor;
    colorInput.addEventListener('change', () => {
        const participantName = nameInput.value.trim();
        if (participantName) {
            document.querySelectorAll('#tripEquipmentContainer .equipment-item-row').forEach(row => {
                const assigneeSelect = row.querySelector('.equipment-assignee');
                if (assigneeSelect && assigneeSelect.value === participantName) {
                    updateEquipmentItemBackground(assigneeSelect);
                }
            });
        }
    });


    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-icon btn-danger btn-sm';
    removeBtn.innerHTML = '<i class="fas fa-user-minus"></i>';
    removeBtn.title = 'Teilnehmer entfernen';
    removeBtn.onclick = () => {
        const removedParticipantName = nameInput.value.trim();
        div.remove();
        document.querySelectorAll('#tripEquipmentContainer .equipment-assignee').forEach(select => {
            if (select.value === removedParticipantName) {
                select.value = "";
                updateEquipmentItemBackground(select);
            }
        });
        populateTripEquipmentList(document.getElementById('equipmentFilterType').value, getCurrentSelectedEquipment());
    };

    div.appendChild(nameInput);
    div.appendChild(colorInput);
    div.appendChild(removeBtn);
    container.appendChild(div);
    populateTripEquipmentList(document.getElementById('equipmentFilterType').value, getCurrentSelectedEquipment());
}
function getCurrentSelectedEquipment() {
    const equipmentData = [];
    document.querySelectorAll('#tripEquipmentContainer .equipment-item-row').forEach(row => {
        const checkbox = row.querySelector('input[type="checkbox"]');
        const select = row.querySelector('.equipment-assignee');
        equipmentData.push({
            id: checkbox.value,
            selected: checkbox.checked,
            broughtBy: select ? select.value : null
        });
    });
    return equipmentData;
}
function populateTripEquipmentList(filterCategoryDisplayName = 'All', preSelectedEquipment = []) {
    const container = document.getElementById('tripEquipmentContainer');
    container.innerHTML = '';

    const currentParticipants = [];
    document.querySelectorAll('#tripParticipantsContainer .participant-field').forEach(pf => {
        const name = pf.querySelector('.participant-name').value.trim();
        const color = pf.querySelector('.participant-color').value;
        if (name) currentParticipants.push({ name, color });
    });

    let itemsToShow = [...equipmentCatalog];
    if (filterCategoryDisplayName !== 'All') {
        itemsToShow = itemsToShow.filter(item => item.category === filterCategoryDisplayName || item.category === "Allgemein");
    }
    itemsToShow.sort((a,b) => a.name.localeCompare(b.name));

    itemsToShow.forEach(item => {
        const preSelectedItemData = preSelectedEquipment.find(psi => psi.id === item.id);
        const isChecked = preSelectedItemData ? preSelectedItemData.selected : false;
        const broughtBy = preSelectedItemData ? preSelectedItemData.broughtBy : null;

        const div = document.createElement('div');
        div.className = 'equipment-item-row';

        let selectOptions = '<option value="">Niemand</option>';
        currentParticipants.forEach(p => {
            selectOptions += `<option value="${p.name}" ${broughtBy === p.name ? 'selected' : ''}>${p.name}</option>`;
        });

        const label = document.createElement('label');
        label.htmlFor = `trip_equip_${item.id}`;
        label.textContent = `${item.name} `;
        const categorySpan = document.createElement('span');
        categorySpan.style.fontSize = '0.8em';
        categorySpan.style.color = 'var(--text-secondary)';
        categorySpan.textContent = `(${item.category})`;
        label.appendChild(categorySpan);

        div.innerHTML = `
            <input type="checkbox" id="trip_equip_${item.id}" value="${item.id}" ${isChecked ? 'checked' : ''}>
        `;
        div.appendChild(label);
        div.innerHTML += `
            <select class="form-control equipment-assignee" onchange="updateEquipmentItemBackground(this)">
                ${selectOptions}
            </select>
        `;
        container.appendChild(div);
        updateEquipmentItemBackground(div.querySelector('.equipment-assignee'));
    });
}
function getContrastYIQ(hexcolor){
    if (!hexcolor) return '#000000';
    hexcolor = hexcolor.replace("#", "");
    if (hexcolor.length === 3) hexcolor = hexcolor.split('').map(char => char + char).join('');
    if (hexcolor.length !== 6) return '#000000';
    const r = parseInt(hexcolor.substr(0,2),16);
    const g = parseInt(hexcolor.substr(2,2),16);
    const b = parseInt(hexcolor.substr(4,2),16);
    const yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? '#000000' : '#FFFFFF';
}
function updateEquipmentItemBackground(selectElement) {
    const selectedParticipantName = selectElement.value;
    const itemRow = selectElement.closest('.equipment-item-row');
    const itemLabel = itemRow.querySelector('label');
    let newBackgroundColor = 'var(--bg-secondary)';
    let textColor = 'var(--text-primary)';

    if (document.body.getAttribute('data-theme') === 'dark') {
        newBackgroundColor = 'var(--bg-tertiary)'; // Dunklerer Hintergrund für Dark Mode
        textColor = 'var(--text-primary)';
    }


    if (selectedParticipantName) {
        let participantColor = null;
        document.querySelectorAll('#tripParticipantsContainer .participant-field').forEach(pf => {
            const name = pf.querySelector('.participant-name').value.trim();
            if (name === selectedParticipantName) {
                participantColor = pf.querySelector('.participant-color').value;
            }
        });
        if (participantColor) {
            newBackgroundColor = participantColor;
            textColor = getContrastYIQ(participantColor);
        }
    }
    itemRow.style.backgroundColor = newBackgroundColor;
    if (itemLabel) itemLabel.style.color = textColor;
    selectElement.style.color = textColor;
    selectElement.style.backgroundColor = newBackgroundColor; // Auch Select Hintergrund
     // Randfarbe für Dark Mode anpassen, um Sichtbarkeit zu gewährleisten
    if (document.body.getAttribute('data-theme') === 'dark' && selectedParticipantName) {
        selectElement.style.borderColor = textColor; // Kontrastierende Randfarbe
    } else {
        selectElement.style.borderColor = ''; // Standardrandfarbe
    }
}
function addEquipmentCatalogItemFromTripModal() {
    const nameInput = document.getElementById('newEquipmentItemNameInput');
    const categorySelect = document.getElementById('newEquipmentItemCategorySelect');
    const itemName = capitalizeFirstLetter(nameInput.value.trim());
    const itemCategory = categorySelect.value; // Ist der Anzeigename

    if (itemName && itemCategory) {
        const newItemId = itemName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/gi, '') + '_' + Date.now().toString().slice(-5);
        if (!equipmentCatalog.some(item => item.name.toLowerCase() === itemName.toLowerCase() && item.category === itemCategory)) {
            equipmentCatalog.push({ id: newItemId, name: itemName, category: itemCategory });
            saveData();
            populateTripEquipmentList(document.getElementById('equipmentFilterType').value, getCurrentSelectedEquipment());
            updateSettingsTabViews();
            nameInput.value = '';
            const newCheckbox = document.getElementById(`trip_equip_${newItemId}`);
            if (newCheckbox) newCheckbox.checked = true;

            alert(`'${itemName}' wurde zum Katalog (${itemCategory}) hinzugefügt.`);
        } else { alert("Dieser Gegenstand existiert bereits in dieser Kategorie im Katalog."); }
    } else { alert("Bitte Name und Kategorie für den neuen Kataloggegenstand angeben."); }
}
function handleTripPlanningSubmit(event) {
    event.preventDefault();
    const tripIdInput = document.getElementById('tripId').value;
    const tripId = tripIdInput ? parseInt(tripIdInput) : null;

    const participantsData = [];
    document.querySelectorAll('#tripParticipantsContainer .participant-field').forEach(pf => {
        const name = pf.querySelector('.participant-name').value.trim();
        const color = pf.querySelector('.participant-color').value;
        if (name) participantsData.push({ name, color });
    });

    const equipmentDataForTrip = [];
    document.querySelectorAll('#tripEquipmentContainer .equipment-item-row input[type="checkbox"]:checked').forEach(checkbox => {
        const row = checkbox.closest('.equipment-item-row');
        const assigneeSelect = row.querySelector('.equipment-assignee');
        const broughtBy = assigneeSelect ? assigneeSelect.value : null;
        const itemFromCatalog = equipmentCatalog.find(ec => ec.id === checkbox.value);
        if (itemFromCatalog) {
             equipmentDataForTrip.push({ id: itemFromCatalog.id, name: itemFromCatalog.name, category: itemFromCatalog.category, broughtBy: broughtBy || null });
        }
    });

    const tripTypeDisplayName = document.getElementById('tripTypeSelect').value; // Anzeigename
    const tripData = {
        id: tripId || Date.now(),
        date: document.getElementById('tripDate').value,
        time: document.getElementById('tripTime').value,
        type: tripTypeDisplayName, // Speichere den Anzeigenamen der Angelart
        gewaesserId: document.getElementById('tripGewaesser').value,
        participants: participantsData,
        equipment: equipmentDataForTrip,
        notes: document.getElementById('tripNotes').value
    };

    if (!tripData.date || !tripData.gewaesserId || !tripData.type) { alert("Bitte Datum, Angelart und Gewässer angeben."); return; }

    if (tripId) {
        const index = plannedTrips.findIndex(t => t.id === tripId);
        if (index > -1) plannedTrips[index] = tripData;
    } else {
        plannedTrips.push(tripData);
    }
    plannedTrips.sort((a,b) => new Date(a.date) - new Date(b.date) || (a.time && b.time ? a.time.localeCompare(b.time) : 0));

    saveData(); renderCalendar(); closeTripPlanningModal();
    alert(tripId ? 'Trip aktualisiert!' : 'Trip geplant!');
}
function deletePlannedTrip(tripId) {
    if (confirm("Geplanten Trip wirklich löschen?")) {
        plannedTrips = plannedTrips.filter(trip => trip.id !== tripId);
        saveData(); renderCalendar(); closeDayModal();
        alert("Geplanter Trip gelöscht.");
    }
}
async function exportTripToPDF() {
    const { jsPDF } = window.jspdf;
    if (!jsPDF) {
        alert("PDF-Bibliothek (jsPDF) nicht geladen. Export nicht möglich.");
        return;
    }
    const doc = new jsPDF({
        orientation: 'p', // portrait
        unit: 'mm',       // millimeter
        format: 'a4'      // A4 Format
    });

    const pageMargin = 15;
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const contentWidth = pageWidth - (2 * pageMargin);
    const lineHeight = 6; // Höhe einer Textzeile in mm
    let currentY = pageMargin;
    const colorBoxSize = 3; // Größe des Farbrechtecks in mm
    const textOffsetFromBox = 2; // Abstand Text vom Farbrechteck

    function addPageIfNecessary(neededHeight) {
        if (currentY + neededHeight > pageHeight - pageMargin) {
            doc.addPage();
            currentY = pageMargin;
            return true;
        }
        return false;
    }

    // --- Header ---
    const tripType = document.getElementById('tripTypeSelect').value;
    const tripDateValue = document.getElementById('tripDate').value;
    const tripDate = tripDateValue ? new Date(tripDateValue).toLocaleDateString('de-DE') : 'Unbekanntes Datum';
    const tripTime = document.getElementById('tripTime').value;
    const gewaesserId = document.getElementById('tripGewaesser').value;
    const gewaesserName = getGewaesserName(gewaesserId) || 'Unbekanntes Gewässer';
    const tripNotes = document.getElementById('tripNotes').value;

    doc.setFontSize(18);
    doc.text(`Angel-Trip: ${tripType} am ${tripDate}${tripTime ? ' um ' + tripTime + ' Uhr' : ''}`, pageMargin, currentY);
    currentY += lineHeight * 1.5;

    doc.setFontSize(12);
    doc.text(`Gewässer: ${gewaesserName}`, pageMargin, currentY);
    currentY += lineHeight;

    if (tripNotes) {
        addPageIfNecessary(lineHeight * 2);
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text("Notizen:", pageMargin, currentY);
        currentY += lineHeight;
        doc.setFont(undefined, 'normal');
        doc.setFontSize(10);
        const notesLines = doc.splitTextToSize(tripNotes, contentWidth);
        notesLines.forEach(line => {
            addPageIfNecessary(lineHeight);
            doc.text(line, pageMargin, currentY);
            currentY += lineHeight;
        });
    }
    currentY += lineHeight;

    // --- Teilnehmer ---
    const participantsDataFromForm = [];
    document.querySelectorAll('#tripParticipantsContainer .participant-field').forEach(pf => {
        const name = pf.querySelector('.participant-name').value.trim();
        const color = pf.querySelector('.participant-color').value;
        if (name) participantsDataFromForm.push({ name, color });
    });

    if (participantsDataFromForm.length > 0) {
        addPageIfNecessary(lineHeight * 2);
        doc.setFontSize(14);
        doc.setFont(undefined, 'bold');
        doc.text("Teilnehmer:", pageMargin, currentY);
        currentY += lineHeight;
        doc.setFont(undefined, 'normal');
        doc.setFontSize(10);

        participantsDataFromForm.forEach(p => {
            addPageIfNecessary(lineHeight);
            // Farbrechteck
            doc.setFillColor(p.color); // Farbe als Hex-String (z.B. "#FF0000")
            doc.rect(pageMargin, currentY - (lineHeight * 0.65), colorBoxSize, colorBoxSize, 'F'); // 'F' für fill
            doc.setTextColor(0, 0, 0); // Textfarbe zurücksetzen
            doc.text(p.name, pageMargin + colorBoxSize + textOffsetFromBox, currentY);
            currentY += lineHeight;
        });
    } else {
        addPageIfNecessary(lineHeight);
        doc.setFontSize(10);
        doc.text("Keine Teilnehmer angegeben.", pageMargin, currentY);
        currentY += lineHeight;
    }
    currentY += lineHeight / 2;

    // --- Packliste ---
    addPageIfNecessary(lineHeight * 2);
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text("Packliste:", pageMargin, currentY);
    currentY += lineHeight;
    doc.setFont(undefined, 'normal');
    doc.setFontSize(10);

    let itemsPrinted = false;
    document.querySelectorAll('#tripEquipmentContainer .equipment-item-row').forEach(row => {
        const checkbox = row.querySelector('input[type="checkbox"]');
        if (checkbox.checked) {
            itemsPrinted = true;
            const itemName = row.querySelector('label').textContent.split('(')[0].trim();
            const assigneeSelect = row.querySelector('.equipment-assignee');
            const broughtByName = assigneeSelect ? assigneeSelect.value : null;

            let itemText = `- ${itemName}`;
            let participantColorForEquipment = null;

            if (broughtByName) {
                const assignedParticipant = participantsDataFromForm.find(p => p.name === broughtByName);
                if (assignedParticipant) {
                    participantColorForEquipment = assignedParticipant.color;
                }
            }

            addPageIfNecessary(lineHeight);
            doc.setTextColor(0, 0, 0); // Standard Textfarbe Schwarz

            if (broughtByName && participantColorForEquipment) {
                const itemTextPart = `- ${itemName} (mitzubringen von: `;
                const itemTextWidth = doc.getTextWidth(itemTextPart);
                doc.text(itemTextPart, pageMargin, currentY);

                doc.setFillColor(participantColorForEquipment);
                doc.rect(pageMargin + itemTextWidth, currentY - (lineHeight * 0.65), colorBoxSize, colorBoxSize, 'F');
                doc.text(broughtByName + ")", pageMargin + itemTextWidth + colorBoxSize + textOffsetFromBox, currentY);
            } else if (broughtByName) { // Teilnehmer zugewiesen, aber keine Farbe (sollte nicht passieren, Fallback)
                doc.text(`${itemText} (mitzubringen von: ${broughtByName})`, pageMargin, currentY);
            }
            else { // Nicht zugewiesen
                doc.text(itemText, pageMargin, currentY);
            }
            currentY += lineHeight;
        }
    });

    if (!itemsPrinted) {
        addPageIfNecessary(lineHeight);
        doc.text("Keine Items für die Packliste ausgewählt.", pageMargin, currentY);
    }

    doc.save(`Angel-Trip_${tripType}_${tripDate.replace(/\./g, '-')}.pdf`);
    alert("PDF wird generiert...");
}


// Settings Tab Management
function updateSettingsTabViews() {
    const fishingTypesContainer = document.getElementById('fishingTypesSettingsContainer');
    fishingTypesContainer.innerHTML = '';
    fishingTypes.sort().forEach(type => {
        const div = document.createElement('div');
        div.className = 'settings-item-row';
        div.innerHTML = `<span>${type}</span><button class="btn btn-icon btn-danger btn-sm" onclick="deleteFishingType('${type}')"><i class="fas fa-trash"></i></button>`;
        fishingTypesContainer.appendChild(div);
    });
    populateAllFishingTypeSelects();

    const equipmentCatalogContainer = document.getElementById('equipmentCatalogSettingsContainer');
    equipmentCatalogContainer.innerHTML = '';
    equipmentCatalog.sort((a,b) => a.category.localeCompare(b.category) || a.name.localeCompare(b.name)).forEach(item => {
        const div = document.createElement('div');
        div.className = 'settings-item-row';
        div.innerHTML = `<div><span>${item.name}</span><small class="item-details">Kategorie: ${item.category}</small></div><button class="btn btn-icon btn-danger btn-sm" onclick="deleteEquipmentCatalogItem('${item.id}')"><i class="fas fa-trash"></i></button>`;
        equipmentCatalogContainer.appendChild(div);
    });
    updateUserEquipmentSetsDisplay();
}
function addFishingTypeFromSettings() {
    const input = document.getElementById('newFishingTypeSettingInput');
    const newType = capitalizeFirstLetter(input.value.trim());
    if (newType && !fishingTypes.includes(newType)) {
        fishingTypes.push(newType);
        saveData(); updateSettingsTabViews(); input.value = '';
    } else if (fishingTypes.includes(newType)) alert("Diese Angelart existiert bereits.");
}
function deleteFishingType(typeToDelete) {
    if (confirm(`Angelart "${typeToDelete}" wirklich löschen? Dies beeinflusst Filter und Kategorien.`)) {
        const isUsedInEquipment = equipmentCatalog.some(item => item.category === typeToDelete);
        const isUsedInTrips = plannedTrips.some(trip => trip.type === typeToDelete);
        const isUsedInSets = userEquipmentSets.some(set => set.applicableFishingTypes && set.applicableFishingTypes.includes(typeToDelete));

        if (isUsedInEquipment || isUsedInTrips || isUsedInSets) {
            if (!confirm(`"${typeToDelete}" wird noch verwendet. Trotzdem löschen? Betroffene Einträge müssen ggf. manuell angepasst werden.`)) return;
            equipmentCatalog.forEach(item => { if (item.category === typeToDelete) item.category = "Allgemein"; });
            plannedTrips.forEach(trip => { if (trip.type === typeToDelete) trip.type = "Allgemein"; });
            userEquipmentSets.forEach(set => {
                if (set.applicableFishingTypes) {
                    set.applicableFishingTypes = set.applicableFishingTypes.filter(ft => ft !== typeToDelete);
                }
            });
        }
        fishingTypes = fishingTypes.filter(type => type !== typeToDelete);
        saveData(); updateSettingsTabViews();
    }
}
function addEquipmentCatalogItemFromSettings() {
    const nameInput = document.getElementById('newEquipmentCatalogNameSettingInput');
    const categorySelect = document.getElementById('newEquipmentCatalogCategorySettingSelect');
    const itemName = capitalizeFirstLetter(nameInput.value.trim());
    const itemCategory = categorySelect.value; // Anzeigename

    if (itemName && itemCategory) {
        const newItemId = itemName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/gi, '') + '_' + Date.now().toString().slice(-5);
        if (!equipmentCatalog.some(item => item.name.toLowerCase() === itemName.toLowerCase() && item.category === itemCategory)) {
            equipmentCatalog.push({ id: newItemId, name: itemName, category: itemCategory });
            saveData(); updateSettingsTabViews(); nameInput.value = '';
        } else alert("Dieser Gegenstand existiert bereits in dieser Kategorie.");
    } else alert("Bitte Name und Kategorie angeben.");
}
function deleteEquipmentCatalogItem(itemIdToDelete) {
    if (confirm("Diesen Gegenstand aus dem Katalog löschen? Er wird dann auch aus Packlisten geplanter Trips und ggf. aus Ausrüstungs-Sets entfernt.")) {
        equipmentCatalog = equipmentCatalog.filter(item => item.id !== itemIdToDelete);
        plannedTrips.forEach(trip => trip.equipment = trip.equipment.filter(eq => eq.id !== itemIdToDelete));
        userEquipmentSets.forEach(set => set.items = set.items.filter(item => item.catalogItemId !== itemIdToDelete));
        saveData(); updateSettingsTabViews();
        if (document.getElementById('tripPlanningModal').classList.contains('active')) {
            populateTripEquipmentList(document.getElementById('equipmentFilterType').value, getCurrentSelectedEquipment());
        }
        updateUserEquipmentSetsDisplay();
    }
}

// User Equipment Set Functions
let currentEditingUserSetId = null;

function openUserEquipmentSetModal(setId = null) {
    const modal = document.getElementById('userEquipmentSetModal');
    const form = document.getElementById('userEquipmentSetForm');
    form.reset();
    document.getElementById('userEquipmentSetItemsContainer').innerHTML = '';
    const applicableTypesContainer = document.getElementById('userSetApplicableFishingTypesContainer');
    applicableTypesContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);

    currentEditingUserSetId = setId;

    if (setId) {
        const set = userEquipmentSets.find(s => s.id === setId);
        if (set) {
            document.getElementById('userEquipmentSetModalTitle').textContent = "Ausrüstungs-Set bearbeiten";
            document.getElementById('editingUserEquipmentSetId').value = set.id;
            document.getElementById('userEquipmentSetName').value = set.name;
            document.getElementById('userEquipmentSetNotes').value = set.notes || '';
            set.items.forEach(item => addUserEquipmentSetItemField(item.catalogItemId, item.details));
            if (set.applicableFishingTypes) {
                set.applicableFishingTypes.forEach(type => {
                    const checkbox = applicableTypesContainer.querySelector(`input[value="${type}"]`);
                    if (checkbox) checkbox.checked = true;
                });
            }
        } else {
            console.error("Ausrüstungs-Set zum Bearbeiten nicht gefunden:", setId);
            document.getElementById('userEquipmentSetModalTitle').textContent = "Neues Ausrüstungs-Set erstellen";
            addUserEquipmentSetItemField();
        }
    } else {
        document.getElementById('userEquipmentSetModalTitle').textContent = "Neues Ausrüstungs-Set erstellen";
        document.getElementById('editingUserEquipmentSetId').value = '';
        addUserEquipmentSetItemField();
    }
    modal.classList.add('active');
}

function closeUserEquipmentSetModal() {
    document.getElementById('userEquipmentSetModal').classList.remove('active');
    currentEditingUserSetId = null;
}

function addUserEquipmentSetItemField(catalogItemId = '', details = '') {
    const container = document.getElementById('userEquipmentSetItemsContainer');
    const itemDiv = document.createElement('div');
    itemDiv.className = 'user-equipment-item';

    const select = document.createElement('select');
    select.className = 'form-control';
    select.innerHTML = '<option value="">Katalog-Item wählen...</option>';
    equipmentCatalog.sort((a,b) => a.name.localeCompare(b.name)).forEach(item => {
        select.innerHTML += `<option value="${item.id}" ${item.id === catalogItemId ? 'selected' : ''}>${item.name} (${item.category})</option>`;
    });

    const detailsInput = document.createElement('input');
    detailsInput.type = 'text';
    detailsInput.className = 'form-control form-control-sm';
    detailsInput.placeholder = 'Menge/Details (z.B. 2 Stück)';
    detailsInput.style.maxWidth = '200px';
    detailsInput.value = details;

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-icon btn-danger btn-sm';
    removeBtn.innerHTML = '<i class="fas fa-trash"></i>';
    removeBtn.onclick = () => itemDiv.remove();

    itemDiv.appendChild(select);
    itemDiv.appendChild(detailsInput);
    itemDiv.appendChild(removeBtn);
    container.appendChild(itemDiv);
}

function handleUserEquipmentSetSubmit(event) {
    event.preventDefault();
    const setName = document.getElementById('userEquipmentSetName').value.trim();
    if (!setName) {
        alert("Bitte einen Namen für das Set angeben.");
        return;
    }

    const itemsData = [];
    document.querySelectorAll('#userEquipmentSetItemsContainer .user-equipment-item').forEach(row => {
        const catalogItemId = row.querySelector('select').value;
        const details = row.querySelector('input[type="text"]').value.trim();
        if (catalogItemId) {
            itemsData.push({ catalogItemId, details });
        }
    });

    if (itemsData.length === 0) {
        alert("Bitte mindestens einen Gegenstand zum Set hinzufügen.");
        return;
    }

    const applicableTypes = [];
    document.querySelectorAll('#userSetApplicableFishingTypesContainer input[type="checkbox"]:checked').forEach(cb => {
        applicableTypes.push(cb.value);
    });


    const setIdInput = document.getElementById('editingUserEquipmentSetId').value;
    const existingSetId = setIdInput ? parseInt(setIdInput) : null;

    const setData = {
        id: existingSetId || Date.now(),
        name: setName,
        items: itemsData,
        applicableFishingTypes: applicableTypes, // Anzeigenamen speichern
        notes: document.getElementById('userEquipmentSetNotes').value.trim()
    };

    if (existingSetId) {
        const index = userEquipmentSets.findIndex(s => s.id === existingSetId);
        if (index > -1) userEquipmentSets[index] = setData;
    } else {
        userEquipmentSets.push(setData);
    }

    saveData();
    updateUserEquipmentSetsDisplay();
    closeUserEquipmentSetModal();
    alert(existingSetId ? "Set aktualisiert!" : "Set erstellt!");
}

function updateUserEquipmentSetsDisplay() {
    const container = document.getElementById('userEquipmentSetsContainer');
    container.innerHTML = '';
    if (userEquipmentSets.length === 0) {
        container.innerHTML = '<p style="color:var(--text-secondary);">Noch keine eigenen Sets erstellt.</p>';
        return;
    }
    userEquipmentSets.sort((a,b) => a.name.localeCompare(b.name)).forEach(set => {
        const div = document.createElement('div');
        div.className = 'settings-item-row';
        let itemsPreview = set.items.slice(0, 3).map(item => {
            const catalogItem = equipmentCatalog.find(ci => ci.id === item.catalogItemId);
            return catalogItem ? catalogItem.name : 'Unbekannt';
        }).join(', ');
        if (set.items.length > 3) itemsPreview += '...';

        let applicableTypesText = 'Nicht zugewiesen';
        if (set.applicableFishingTypes && set.applicableFishingTypes.length > 0) {
            applicableTypesText = set.applicableFishingTypes.join(', ');
        }


        div.innerHTML = `
            <div>
                <span>${set.name}</span>
                <small class="item-details">Angelarten: ${applicableTypesText}</small>
                <small class="item-details">Enthält: ${itemsPreview || 'Keine Items'} (${set.items.length} Stk.)</small>
                ${set.notes ? `<small class="item-details" style="margin-top:0.2rem;"><em>${set.notes}</em></small>` : ''}
            </div>
            <div>
                <button class="btn btn-icon btn-sm" onclick="openUserEquipmentSetModal(${set.id})"><i class="fas fa-edit"></i></button>
                <button class="btn btn-icon btn-danger btn-sm" onclick="deleteUserEquipmentSet(${set.id})"><i class="fas fa-trash"></i></button>
            </div>`;
        container.appendChild(div);
    });
}

function deleteUserEquipmentSet(setId) {
    if (confirm("Ausrüstungs-Set wirklich löschen?")) {
        userEquipmentSets = userEquipmentSets.filter(s => s.id !== setId);
        saveData();
        updateUserEquipmentSetsDisplay();
    }
}


// Utility Functions
function toggleTheme() { const newTheme = document.body.getAttribute('data-theme')==='dark'?'light':'dark'; document.body.setAttribute('data-theme',newTheme); localStorage.setItem('theme',newTheme); document.getElementById('themeIcon').className = newTheme==='dark'?'fas fa-sun':'fas fa-moon'; const rootStyle = getComputedStyle(document.documentElement); const bgPrimaryColor = rootStyle.getPropertyValue('--bg-primary').trim(); document.documentElement.style.setProperty('--bg-primary-rgb', colorToRgb(bgPrimaryColor)); }
function getGewaesserName(id) { if (!id) return null; const g=gewaesser.find(gw=> String(gw.id) === String(id)); return g?g.name:null; }
function getMethodName(keyOrDisplayName) {
    // Prüfe, ob es ein bekannter interner Key ist
    if (Object.values(methodKeyMap).includes(keyOrDisplayName)) {
        const displayName = Object.keys(methodKeyMap).find(k => methodKeyMap[k] === keyOrDisplayName);
        return displayName || capitalizeFirstLetter(keyOrDisplayName || "") || 'N/A';
    }
    // Ansonsten ist es wahrscheinlich schon ein Anzeigename
    if (fishingTypes.includes(keyOrDisplayName)) {
        return keyOrDisplayName;
    }
    return capitalizeFirstLetter(keyOrDisplayName || "") || 'N/A';
}
function getTypeName(key) { const t={'river':'Fluss','lake':'See','reservoir':'Talsperre','pond':'Teich','canal':'Kanal','stream':'Bach', 'spot':'Spot', 'other': 'Anderer Typ'}; return t[key]||capitalizeFirstLetter(key||"")||'N/A'; }
function getTimeOfDayName(key) { const n={'dawn':'Morgengrauen','morning':'Morgen','afternoon':'Nachmittag','dusk':'Abenddämmerung','night':'Nacht','late_night':'Späte Nacht'}; return n[key]||capitalizeFirstLetter(key||"")||'N/A'; }
function capitalizeFirstLetter(string) { if(!string) return ''; return string.charAt(0).toUpperCase() + string.slice(1); }
function refreshProbabilities(event) { // event hinzugefügt
    updateProbabilities();
    if (event && event.currentTarget) { // Sicherstellen, dass event und currentTarget existieren
        const btn = event.currentTarget;
        const icon = btn.querySelector('i');
        if (icon) {
            icon.classList.add('fa-spin');
            setTimeout(() => icon.classList.remove('fa-spin'), 1000);
        }
    }
}

    </script>
    <script>
   let deferredPrompt;
   const installPwaButton = document.getElementById('installPwaButton'); // This ID will be for the button added in the next step

   window.addEventListener('beforeinstallprompt', (e) => {
     // Prevent Chrome 67 and earlier from automatically showing the prompt
     e.preventDefault();
     // Stash the event so it can be triggered later.
     deferredPrompt = e;
     // Update UI to notify the user they can add to home screen
     if (installPwaButton) {
       installPwaButton.style.display = 'block'; // Or 'inline-block', 'flex', etc.
       console.log('`beforeinstallprompt` event fired, install button shown.');
     } else {
       console.log('`beforeinstallprompt` event fired, but install button not found yet.');
     }
   });

   if (installPwaButton) {
     installPwaButton.addEventListener('click', async () => {
       // Hide our user interface that shows our A2HS button
       installPwaButton.style.display = 'none';
       if (deferredPrompt) {
         // Show the prompt
         deferredPrompt.prompt();
         // Wait for the user to respond to the prompt
         try {
           const choiceResult = await deferredPrompt.userChoice;
           if (choiceResult.outcome === 'accepted') {
             console.log('User accepted the A2HS prompt');
           } else {
             console.log('User dismissed the A2HS prompt');
           }
         } catch (error) {
           console.error('Error with userChoice:', error);
         }
         // We've used the prompt, and can't use it again, discard it
         deferredPrompt = null;
       } else {
         console.log('Install button clicked, but no deferredPrompt available.');
       }
     });
   }

   window.addEventListener('appinstalled', () => {
     // Hide the install button if the app is installed
     if (installPwaButton) {
       installPwaButton.style.display = 'none';
     }
     // Clear the deferredPrompt so it can be garbage collected
     deferredPrompt = null;
     // Optionally, send analytics event to indicate successful install
     console.log('PWA was installed');
   });
    // PWA Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js') // Path relative to index.html
          .then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
          })
          .catch(error => {
            console.log('ServiceWorker registration failed: ', error);
          });
      });
    }
    </script>
</body>
</html>
